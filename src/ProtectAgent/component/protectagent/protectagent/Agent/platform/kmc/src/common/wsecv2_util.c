/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2014-2020. All rights reserved.
 * Description: UTIL common function implementation
 * Author: x00102361
 * Create: 2014-06-16
 * History: 2018-10-08 Zhang Jie (employee ID: 00316590) Rectification by UK
 */

#include "wsecv2_util.h"
#include "securec.h"
#include "wsecv2_callbacks.h"
#include "wsecv2_errorcode.h"
#include "wsecv2_datetime.h"

#define KMC_LOG_CRLF_LENGTH 2
#define BYTE_INT_OFFSET 8

/* Delete the carriage return character. */
static WsecVoid TrimLog(char *log, int logMaxLen, int curLen)
{
    int endPosition;
    if (curLen < 0) {
        return;
    }
    endPosition = curLen - 1;   /* soter 554 */

    if (endPosition > 0 && endPosition < logMaxLen) {
        if (log[endPosition] == '\n') {
            log[endPosition] = '\0';
            endPosition--;
        }
    }
    if (endPosition > 0 && endPosition < logMaxLen) {
        if (log[endPosition] == '\r') {
            log[endPosition] = '\0';
            endPosition--;
        }
    }

/* 2.2 Add newline characters as required. */
/* If the product does not automatically wrap lines when writing logs, add lines to ensure the readability of logs. */
#ifndef WSEC_WRI_LOG_AUTO_END_WITH_CRLF
    endPosition++;
    if ((endPosition >= 0) && (endPosition < (logMaxLen - KMC_LOG_CRLF_LENGTH))) {  /* soter 554 */
        log[endPosition] = '\r';
        endPosition++;
        log[endPosition] = '\n';
        endPosition++;
        log[endPosition] = '\0';
    }
#endif
}

/* This function is used to write log information in CBB through the log registration function of the callback app. */
WsecVoid WsecLog(const char *file, int line, int level, const char *fmt, ...)
{
    va_list marker;
    char logBuff[WSEC_LOG_BUFF_SIZE] = {0};
    const char *fileName = NULL;
    int dateTimeLen;
    int contentLen;
    WsecSysTime nowUtc = { 0, 0, 0, 0, 0, 0, 0 };

    /* Log recording time. */
    if (!WsecGetUtcDateTime(&nowUtc)) {
        return;
    }
    dateTimeLen = sprintf_s(logBuff, (size_t)WSEC_LOG_BUFF_SIZE, "(UTC) %04u-%02u-%02u %02u:%02u:%02u ",
        (unsigned int)nowUtc.kmcYear, (unsigned int)nowUtc.kmcMonth, (unsigned int)nowUtc.kmcDate,
        (unsigned int)nowUtc.kmcHour, (unsigned int)nowUtc.kmcMinute, (unsigned int)nowUtc.kmcSecond);
    if (dateTimeLen < 0 || dateTimeLen >= (WSEC_LOG_BUFF_SIZE - KMC_LOG_CRLF_LENGTH)) {
        return;
    }

    /* 1. Parse the log string through formatting. */
    va_start(marker, fmt);
    contentLen = vsprintf_s(logBuff + dateTimeLen,
        (const size_t)(unsigned int)(WSEC_LOG_BUFF_SIZE - (dateTimeLen + KMC_LOG_CRLF_LENGTH)),
        fmt,
        marker);
    va_end(marker);
    if (contentLen < 0 || (dateTimeLen + contentLen) >= (WSEC_LOG_BUFF_SIZE - KMC_LOG_CRLF_LENGTH)) {
        return;
    }

    /* 2. Automatically supplement or delete line breaks in logs based on the features of logs generated by products. */
    /* 2.1 Delete the line feed character at the end of the log string. */
    TrimLog(logBuff, WSEC_LOG_BUFF_SIZE, dateTimeLen + contentLen);

    /* 3. Obtain the file name (excluding the path). */
    fileName = strrchr(file, '\\');
    if (fileName == NULL) {
        fileName = strrchr(file, '/');
    }
    if (fileName != NULL) {
        fileName++;
    } else {
        fileName = file;
    }
    /* 4. Write logs. */
    WsecWriteLog((int)level, "WSEC_CBB", fileName, line, logBuff);
}

/* byte array converted to unsigned long long number */
unsigned long long WsecByteArrToBigInt(const unsigned char *byteArr, size_t len)
{
    size_t i;
    unsigned long long ret = 0;
    (void)len;
    WSEC_ASSERT(!(len < sizeof(unsigned long long)));
    for (i = 0; i < sizeof(unsigned long long); i++) {
        ret = (ret << BYTE_INT_OFFSET) + (unsigned long long)byteArr[i]; /* Move 8 bits */
    }
    return ret;
}

/* Encryption (software-layer root key or master key) */
unsigned long WsecKmcHwEncData(WsecHandle handle, const unsigned char *plaintext, unsigned int plaintextLen,
    unsigned char *ciphertext, unsigned int *ciphertextLen)
{
    WsecPlainCipherBuffs buffs = { NULL, 0, NULL, NULL };
    unsigned long ret;
    const unsigned char *extraData = NULL;
    unsigned int extraLen = 0;
    ret = WsecHwGetEncExtraData(&extraData, &extraLen);
    if (ret != WSEC_SUCCESS) {
        return ret;
    }
    buffs.in = plaintext;
    buffs.inLen = plaintextLen;
    buffs.out = ciphertext;
    buffs.outLen = ciphertextLen;

    return WsecHwEncData(handle, extraData, extraLen, (const WsecPlainCipherBuffs *)&buffs);
}

/* Decryption (software-layer root key or master key) */
unsigned long WsecKmcHwDecData(WsecHandle handle, const unsigned char *ciphertext, unsigned int ciphertextLen,
    unsigned char *plaintext, unsigned int *plaintextLen)
{
    WsecPlainCipherBuffs buffs = { NULL, 0, NULL, NULL };
    unsigned long ret;
    const unsigned char *extraData = NULL;
    unsigned int extraLen = 0;
    ret = WsecHwGetDecExtraData(&extraData, &extraLen);
    if (ret != WSEC_SUCCESS) {
        return WSEC_FAILURE;
    }
    buffs.in = ciphertext;
    buffs.inLen = ciphertextLen;
    buffs.out = plaintext;
    buffs.outLen = plaintextLen;
    return WsecHwDecData(handle, extraData, extraLen, (const WsecPlainCipherBuffs *)&buffs);
}
