/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2014-2020. All rights reserved.
 * Description: Implementation of the data protection module in SDP V1
 * Author: x00102361
 * Create: 2014-06-16
 * History: 2018-10-08 Zhang Jie (employee ID: 00316590) UK rectification, compatible with V1
 */

#include "sdpv1_itf.h"
#include "securec.h"
#include "sdpv1_tlv.h"
#include "sdpv3_alg.h"
#include "sdp_utils.h"
#include "cacv2_pri.h"
#include "kmcv2_itf.h"
#include "kmcv2_pri.h"
#include "wsecv2_file.h"
#include "wsecv2_datetime.h"
#include "wsecv2_order.h"
#include "wsecv2_mem.h"
#include "wsecv2_errorcode.h"
#include "wsecv2_util.h"

#ifndef WSEC_COMPILE_SDP
#error Please defined 'WSEC_COMPILE_SDP' to compile
#endif

/* Ciphertext structure version */
#define SDP_PWD_CIPHER_VER  1
#define SDP_CIPHER_FILE_VER 1

#define KMC_PLAIN_BLOCK_MAX_LEN 4096

static unsigned char g_cipherFileFlag[SDP_CIPHER_FILE_FLAG] = {
    0x7F, 0x11, 0x3A, 0xBE, 0x84, 0x18, 0x20, 0x0D, 0xE0, 0x45, 0x2F, 0x61, 0x3D, 0x34, 0xD5, 0x16,
    0x31, 0x99, 0x77, 0x74, 0x6F, 0xEE, 0x6D, 0x76, 0xC8, 0x92, 0xC4, 0x73, 0xF0, 0x17, 0x96, 0x87
};

/* PWD header */
#pragma pack(1)
typedef struct TagSdpPwdHeader{
    WsecUint32    version;            /* Data protection module version */
    WsecUint32    algId;              /* Algorithm ID */
    /* Iteration round, which is configured by the application for the key management module to derive working keys. */
    WsecUint32    iter;
    unsigned char salt[SDP_SALT_LEN]; /* Salt generated by the data protection module. */
    WsecUint32    cipherLen;          /* Length of the encrypted password */
} SdpPwdHeader;
#pragma pack()

/* Context definition for big data encryption and decryption */
typedef struct TagSdpCipherCtx{
    WsecHandle      cacCtx;       /* Context of the CAC adaptation layer */
    WsecHandle      hmacCtx;      /* integrity context */
    SdpCipherHeader cipherHeader; /* Encryption and decryption context */
} SdpCipherCtx;

typedef struct TagSdpHeaderId{
    WsecUint32 domainId;
    WsecUint32 algId;
    WsecBool hasHmac;
    WsecUint32 hmacAlgId;
} SdpHeaderId;

#define SDP_CIPHER_CTX_LEN sizeof(SdpCipherCtx)

/* Calculating the Ciphertext Length Based on the Plaintext Length */
unsigned long SdpGetCipherDataLen(WsecUint32 plainLen, WsecUint32 *cipherLen)
{
    WsecUint32 blockLen = SDP_SYM_MAX_BLOCK_SIZE;
    WsecUint32 hmacLen = 0;
    unsigned long ret;

    if (cipherLen == NULL) {
        return WSEC_ERR_INVALID_ARG;
    }

    ret = SdpGetHmacLen(&hmacLen);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E1("SdpGetHmacLen()=%lu", ret);
        return ret;
    }

    *cipherLen = SDP_CIPHER_HEAD_LEN + (((plainLen / blockLen) + 1) * blockLen) + WSEC_AES_GCM_TAGLEN + hmacLen;

    return WSEC_SUCCESS;
}

/* Password encryption header byte order */
static void SdpCvtByteOrderForSdpPwdHeader(SdpPwdHeader *header, WsecUint32 direction)
{
    WSEC_ASSERT(header);
    WSEC_ASSERT(WSEC_IS2(direction, WBCHOST2NETWORK, WBCNETWORK2HOST));

    if (direction == WBCHOST2NETWORK) {
        header->version = WSEC_H2N_L(header->version);
        header->algId = WSEC_H2N_L(header->algId);
        header->iter = WSEC_H2N_L(header->iter);
        header->cipherLen = WSEC_H2N_L(header->cipherLen);
    } else {
        header->version = WSEC_N2H_L(header->version);
        header->algId = WSEC_N2H_L(header->algId);
        header->iter = WSEC_N2H_L(header->iter);
        header->cipherLen = WSEC_N2H_L(header->cipherLen);
    }
}

/* Filling in the PBKDF2 Header Structure */
static unsigned long SdpFillPwdCipherTextHeader(WsecUint32 algId, WsecUint32 iter, SdpPwdHeader *header)
{
    unsigned long ret;
    WsecUint32 algType = WSEC_ALGTYPE_UNKNOWN;

    WSEC_ASSERT(header != NULL);

    /* Check the number of iterations. */
    if (!KMC_IS_KEYITERATIONS_VALID(iter)) {
        WSEC_LOG_E1("KeyIterations(%u) invalid.", iter);
        return WSEC_ERR_INVALID_ARG;
    }

    /* Obtains algorithm parameters. */
    ret = SdpGetAlgPropertyEx(algId, &algType, NULL, NULL, NULL);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] Get algorithm property failed.");
        return ret;
    }
    if (algType != WSEC_ALGTYPE_PBKDF) {
        WSEC_LOG_E1("[SDP] algType(%u) is out of bounds.", algType);
        return WSEC_ERR_SDP_CONFIG_INCONSISTENT_WITH_USE;
    }

    /* Salt value */
    ret = CacRandom(header->salt, SDP_SALT_LEN);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] CAC calculate random failed.");
        return WSEC_ERR_GET_RAND_FAIL;
    }

    /* Fill in other fields. */
    header->version = SDP_PWD_CIPHER_VER;
    header->algId = algId;
    header->iter = iter;

    return WSEC_SUCCESS;
}

/* Releasing the Encryption Environment */
static void FreeCipherCtx(WsecHandle *sdpCtx)
{
    SdpCipherCtx *ctx = NULL;

    if (sdpCtx == NULL || *sdpCtx == NULL) {
        return;
    }

    ctx = (SdpCipherCtx *)(*sdpCtx);
    if (ctx->cacCtx != NULL) {
        CacCipherFree(&ctx->cacCtx);
    }
    if (ctx->hmacCtx != NULL) {
        SdpFreeHmacCtx(&ctx->hmacCtx);
    }
    WSEC_FREE(ctx);
    *sdpCtx = NULL;
}

/* Ciphertext header, keyLength is input param as max key buffer len and ouput param as filled key buffer len */
static unsigned long SdpFillCipherTextHeader(SdpHeaderId ids, SdpCipherHeader *cipherHeader,
    unsigned char *key, WsecUint32 *keyLength, WsecUint32 *ivLength)
{
    WsecUint32 algType = WSEC_ALGTYPE_UNKNOWN;
    unsigned long ret;
    WsecUint32 ivLen = 0;
    WsecUint32 keyLen = 0;
    WsecUint32 keyId = 0;
    Pbkdf2Param pbkdf2Param;
    /* KMC_KEY_TYPE_ENCRPT must be retained in KMC V1 upgrade scenarios. */
    KmcActiveKeyParam mkParam = { DEFAULT_SDP_DOMAIN_ID, { SDP_V1_SUPPORT_KEY_TYPE_COUNT,
        { KMC_KEY_TYPE_ENCRPT_INTEGRITY, KMC_KEY_TYPE_ENCRPT, KMC_KEY_TYPE_ENCRPT } } };

    /* Check the input parameter. */
    if (cipherHeader == NULL || keyLength == NULL || key == NULL || ivLength == NULL) {
        WSEC_LOG_E2("%s - %d, parameter invalid.", __FUNCTION__, __LINE__);
        return WSEC_ERR_INVALID_ARG;
    }

    /* Obtain the algorithm type, key, and IV. */
    ret = SdpGetAlgPropertyEx(ids.algId, &algType, &keyLen, &ivLen, NULL);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] Get algorithm property failed.");
        return ret;
    }
    if (algType != WSEC_ALGTYPE_SYM) {
        WSEC_LOG_E1("[SDP] algType (%u) is out of bounds.", algType);
        return WSEC_ERR_SDP_CONFIG_INCONSISTENT_WITH_USE;
    }
    if (keyLen > *keyLength) {
        WSEC_LOG_E2("[SDP] keyLen (%u) exceeds the key buffer limit (%u).", keyLen, *keyLength);
        return WSEC_ERR_OUTPUT_BUFF_NOT_ENOUGH;
    }
    /* Obtaining the Working Key */
    pbkdf2Param.salt = cipherHeader->salt;
    pbkdf2Param.saltLen = SDP_SALT_LEN;
    pbkdf2Param.iter = 0;
    mkParam.domainId = ids.domainId;
    ret = GetWorkKey(&mkParam, &keyId, &pbkdf2Param, cipherHeader->iv, ivLen, key, keyLen);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] Get WK failed.");
        return ret;
    }

    /* Fill in other fields. */
    cipherHeader->version = SDP_CIPHER_TEXT_VER1;
    cipherHeader->hmacFlag = (WsecUint32)ids.hasHmac;
    cipherHeader->domain = ids.domainId;
    cipherHeader->algId = ids.algId;
    cipherHeader->iter = (WsecUint32)pbkdf2Param.iter;
    cipherHeader->keyId = keyId;

    *keyLength = keyLen;
    *ivLength = ivLen;

    return ret;
}

/* File Header Structure Byte Order */
static void SdpCvtByteOrder4CipherFileHdr(SdpCipherFileHeader *fileHeader, WsecUint32 direction)
{
    WSEC_ASSERT(fileHeader != NULL);
    WSEC_ASSERT(WSEC_IS2(direction, WBCHOST2NETWORK, WBCNETWORK2HOST));
    if (WBCHOST2NETWORK == direction) {
        fileHeader->version = WSEC_H2N_L(fileHeader->version);
        fileHeader->plainBlockLenMax = WSEC_H2N_L(fileHeader->plainBlockLenMax);
        fileHeader->cipherBlockLenMax = WSEC_H2N_L(fileHeader->cipherBlockLenMax);
    } else {
        fileHeader->version = WSEC_N2H_L(fileHeader->version);
        fileHeader->plainBlockLenMax = WSEC_N2H_L(fileHeader->plainBlockLenMax);
        fileHeader->cipherBlockLenMax = WSEC_N2H_L(fileHeader->cipherBlockLenMax);
    }

    WsecCvtByteOrderForDateTime(&fileHeader->createUtc, direction);
    WsecCvtByteOrderForDateTime(&fileHeader->srcCreateTime, direction);
    WsecCvtByteOrderForDateTime(&fileHeader->srcEditTime, direction);
}

/* Create and write the file header. */
static unsigned long MakeFileHeaderAndWrite(const CallbackGetFileDateTime getFileDateTime, const char *plainFile,
    WsecHandle writeStream, SdpCipherFileHeader *fileHeader)
{
    unsigned long ret;
    /* Prepare the ciphertext file header. */
    fileHeader->plainBlockLenMax = KMC_PLAIN_BLOCK_MAX_LEN;
    if (WsecGetUtcDateTime(&fileHeader->createUtc) == WSEC_FALSE) {
        WSEC_LOG_E("WSEC_GetUtcDateTime() fail.");
        return WSEC_ERR_GET_CURRENT_TIME_FAIL;
    }
    ret = SdpGetCipherDataLen(fileHeader->plainBlockLenMax, &fileHeader->cipherBlockLenMax);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E1("SDP_GetCipherDataLen()=%lu", ret);
        return ret;
    }
    (void)memcpy_s(fileHeader->flag, (size_t)SDP_CIPHER_FILE_FLAG, g_cipherFileFlag, (size_t)SDP_CIPHER_FILE_FLAG);
    fileHeader->version = SDP_CIPHER_FILE_VER;

    if (getFileDateTime) {
        /* Ensure that the time data is invalid to prevent the app from dirtying data. */
        if (getFileDateTime(plainFile, &fileHeader->srcCreateTime, &fileHeader->srcEditTime) == WSEC_FALSE) {
            fileHeader->srcCreateTime.kmcYear = 0;
            fileHeader->srcEditTime.kmcYear = 0;
        }
    }

    SdpCvtByteOrder4CipherFileHdr(fileHeader, WBCHOST2NETWORK);
    ret = WsecWriteTlv(writeStream, SDP_CFT_FILE_HDR, (WsecUint32)sizeof(SdpCipherFileHeader), fileHeader);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E1("WSEC_WriteTlv()=%lu", ret);
        return ret;
    }
    SdpCvtByteOrder4CipherFileHdr(fileHeader, WBCNETWORK2HOST);
    return WSEC_SUCCESS;
}

/* Allocates the encryption buffer. */
static unsigned long MallocBuff(const SdpCipherFileHeader *header, WsecBuff *plainBuff, WsecBuff *cipherBuff)
{
    unsigned long ret = WSEC_SUCCESS;
    WsecBuff tempPlain = { NULL, 0 };
    WsecBuff tempCipher = { NULL, 0 };
    do {
        WSEC_BUFF_ALLOC(tempPlain, header->plainBlockLenMax);
        WSEC_BUFF_ALLOC(tempCipher, header->cipherBlockLenMax);
        if (tempPlain.buff == NULL) {
            WSEC_LOG_E4MALLOC(tempPlain.len);
            ret = WSEC_ERR_MALLOC_FAIL;
            break;
        }
        if (tempCipher.buff == NULL) {
            WSEC_LOG_E4MALLOC(tempCipher.len);
            ret = WSEC_ERR_MALLOC_FAIL;
            break;
        }
        (void)memcpy_s(plainBuff, sizeof(WsecBuff), &tempPlain, sizeof(WsecBuff));
        (void)memcpy_s(cipherBuff, sizeof(WsecBuff), &tempCipher, sizeof(WsecBuff));
    } while (0);
    if (ret != WSEC_SUCCESS) {
        WSEC_FREE(tempPlain.buff);
        WSEC_FREE(tempCipher.buff);
    }
    return ret;
}

/* File encryption */
static unsigned long FileEncrypt(SdpHeaderId ids, long remainLen, const SdpCipherFileHeader *fileHeader,
    WsecHandle readStream, WsecHandle writeStream, WsecBuff *plainBuff, WsecBuff *cipherBuff)
{
    WsecHandle sdpCtx = NULL;
    SdpBodCipherHeader bodHeader;
    unsigned long ret;
    unsigned long temp;
    unsigned char hmacVal[SDP_HMAC_MAX_SIZE] = {0};
    WsecUint32 hmacLen = sizeof(hmacVal);
    WsecBool readSuccess = WSEC_TRUE;
    long remain = remainLen;

    (void)memset_s(&bodHeader, sizeof(bodHeader), 0, sizeof(bodHeader));

    do {
        /* 3.2 Initializing Big Data Encryption */
        ret = SdpEncryptInit(ids.domainId, ids.algId, ids.hmacAlgId, &sdpCtx, &bodHeader);
        ret = CheckResultAndWriteTlv(ret, writeStream, (unsigned char *)&bodHeader, (WsecUint32)sizeof(bodHeader),
            SDP_CFT_CIPHER_HDR);
        if (ret != WSEC_SUCCESS) {
            break;
        }

        /* 3.3 Reading a Plaintext File, Encrypting a Password, and Writing a Ciphertext File */
        while (remain > 0) {
            plainBuff->len = fileHeader->plainBlockLenMax;
            if (plainBuff->len > (WsecUint32)remain) {
                plainBuff->len = (WsecUint32)remain;
            }
            readSuccess = WSEC_FREAD(plainBuff->buff, plainBuff->len, readStream);
            if (readSuccess == WSEC_FALSE) {
                WSEC_LOG_E("Read plain file fail.");
                ret = WSEC_ERR_READ_FILE_FAIL;
                break;
            }
            remain -= (long)plainBuff->len; /* Length of processed plaintext */
            cipherBuff->len = fileHeader->cipherBlockLenMax;
            ret = SdpEncryptUpdate(&sdpCtx, (const unsigned char *)plainBuff->buff, plainBuff->len,
                (unsigned char *)cipherBuff->buff, &cipherBuff->len);
            ret = CheckResultAndWriteTlv(ret, writeStream, (const unsigned char *)cipherBuff->buff, cipherBuff->len, SDP_CFT_CIPHER_BODY);
            if (ret != WSEC_SUCCESS) {
                break;
            }
        }
        cipherBuff->len = fileHeader->cipherBlockLenMax;
        temp = SdpEncryptFinal(&sdpCtx, (unsigned char *)cipherBuff->buff, &cipherBuff->len, hmacVal, &hmacLen);
        if (temp != WSEC_SUCCESS) {
            WSEC_LOG_E1("SDP_EncryptFinal()=%lu", ret);
            ret = temp;
            break;
        }
        ret = CheckResultAndWriteTlv(ret, writeStream, (const unsigned char *)cipherBuff->buff, cipherBuff->len, SDP_CFT_CIPHER_BODY);
        ret = CheckResultAndWriteTlv(ret, writeStream, hmacVal, hmacLen, SDP_CFT_HMAC_VAL);
    } while (0);
    FreeCipherCtx(&sdpCtx);
    return ret;
}

/* fill SpdHeaderId struct */
static void FillSdpHeaderId(SdpHeaderId *ids, WsecUint32 domain,
    WsecUint32 cipherAlgId, WsecUint32 hmacAlgId)
{
    WSEC_ASSERT(ids != NULL);
    ids->domainId  = domain;
    ids->algId     = cipherAlgId;
    ids->hasHmac   = (hmacAlgId != WSEC_ALGID_UNKNOWN) ? WSEC_TRUE : WSEC_FALSE;
    ids->hmacAlgId = hmacAlgId;
}

/* Encrypting a File */
unsigned long SdpFileEncrypt(WsecUint32 domain, WsecUint32 cipherAlgId, WsecUint32 hmacAlgId,
    const char *plainFile, const char *cipherFile, const CallbackGetFileDateTime getFileDateTime)
{
    WsecHandle readStream = NULL;
    WsecHandle writeStream = NULL;
    WsecBuff plainBuff = { NULL, 0 };
    WsecBuff cipherBuff = { NULL, 0 };
    SdpCipherFileHeader fileHeader;
    long remainLen;
    unsigned long ret;
    WsecBool isRemove = WSEC_FALSE; /* Indicates whether to delete the ciphertext file after the operation fails. */
    SdpHeaderId ids = { DEFAULT_SDP_DOMAIN_ID, WSEC_ALGID_UNKNOWN, WSEC_FALSE, WSEC_ALGID_UNKNOWN };
    FillSdpHeaderId(&ids, domain, cipherAlgId, hmacAlgId);
    (void)memset_s(&fileHeader, sizeof(SdpCipherFileHeader), 0, sizeof(SdpCipherFileHeader));
    /* Read the plaintext file, generate the ciphertext, and write the ciphertext. */
    do {
        ret = WsecReadWriteFilePrepare(plainFile, cipherFile, &readStream, &writeStream, &remainLen);
        if (ret != WSEC_SUCCESS) {
            break;
        }
        ret = MakeFileHeaderAndWrite(getFileDateTime, plainFile, writeStream, &fileHeader);
        if (ret != WSEC_SUCCESS) {
            break;
        }
        ret = MallocBuff(&fileHeader, &plainBuff, &cipherBuff);
        if (ret != WSEC_SUCCESS) {
            break;
        }

        /* Writing the Ciphertext File Header */
        isRemove = WSEC_TRUE;
        ret = FileEncrypt(ids, remainLen, &fileHeader, readStream, writeStream, &plainBuff, &cipherBuff);
    } while (0);

    /* Release resources. */
    WSEC_FCLOSE(readStream);
    if (WSEC_FFLUSH(writeStream) != 0) {
        WSEC_LOG_E2("SdpFileEncrypt WSEC_FFLUSH failed, errno %d err %lu", WSEC_FERRNO(writeStream), ret);
        ret = WSEC_ERR_FILE_FLUSH_FAIL;
    }
    WSEC_FCLOSE(writeStream);
    WSEC_CLEAR_FREE(plainBuff.buff, fileHeader.plainBlockLenMax);
    WSEC_BUFF_FREE(cipherBuff);

    /* There is no risk of Face_Condition. If the encryption fails, delete the ciphertext file. */
    if ((ret != WSEC_SUCCESS) && isRemove) {
        WSEC_UNREFER(WSEC_FREMOVE(cipherFile));
    }

    return ret;
}

/* Reads the file header. */
static unsigned long ReadFileHeaderEnsurePlainLen(WsecHandle readStream, SdpCipherFileHeader *fileHeader,
    long *remainLen, WsecBuff *plainBuff)
{
    unsigned long ret = WSEC_SUCCESS;
    WsecTlv tlv = { 0, 0, NULL };
    (void)memset_s(fileHeader, sizeof(SdpCipherFileHeader), 0, sizeof(SdpCipherFileHeader));
    do {
        /* 1. Ciphertext file detection */
        /* 1.1 Reading the Header of the Ciphertext File */
        if (WsecReadTlv(readStream, fileHeader, (WsecUint32)sizeof(SdpCipherFileHeader), &tlv, &ret) == WSEC_FALSE) {
            break; /* In this case, the value of errCode is changed from WsecReadTlv to an error code. */
        }
        if (tlv.tag != SDP_CFT_FILE_HDR) {
            WSEC_LOG_E("file is not expected encrpt file for TLV's tag is not SDP_CFT_FILE_HDR.");
            ret = WSEC_ERR_FILE_FORMAT;
            break;
        }
        SdpCvtByteOrder4CipherFileHdr(fileHeader, WBCNETWORK2HOST);

        /* 1) Check the format. */
        if (WSEC_MEMCMP(g_cipherFileFlag, fileHeader->flag, SDP_CIPHER_FILE_FLAG) != 0) {
            WSEC_LOG_E("The format of the encrypted file is incorrect.");
            ret = WSEC_ERR_FILE_FORMAT;
            break;
        }

        /* 2) Check whether the version is correct. */
        if (fileHeader->version != SDP_CIPHER_FILE_VER) {
            WSEC_LOG_E("The version of the encrypted file is incorrect.");
            ret = WSEC_ERR_SDP_VERSION_INCOMPATIBLE;
            break;
        }
        ret = SdpSafeSubTwo((WsecUint32)(sizeof(tlv.tag) + sizeof(tlv.len)), tlv.len, remainLen);
        if (ret != WSEC_SUCCESS) {
            break;
        }
        plainBuff->len = fileHeader->plainBlockLenMax;
    } while (0);
    return ret;
}

static unsigned long ReadBodHeader(WsecHandle readStream, long *remainLen, SdpBodCipherHeader *bodHeader, WsecTlv *tlv)
{
    unsigned long ret = WSEC_SUCCESS;

    do {
        if (WsecReadTlv(readStream, bodHeader, (WsecUint32)sizeof(SdpBodCipherHeader), tlv, &ret) == WSEC_FALSE) {
            break;
        }
        if (tlv->tag != SDP_CFT_CIPHER_HDR) {
            WSEC_LOG_E("the file is not expected encrypt file for TLV's tag not is SDP_CFT_CIPHER_HDR.");
            ret = WSEC_ERR_FILE_FORMAT;
            break;
        }

        ret = SdpSafeSubTwo((WsecUint32)(sizeof(tlv->tag) + sizeof(tlv->len)), tlv->len, remainLen);
        if (ret != WSEC_SUCCESS) {
            break;
        }
    } while (0);
    return ret;
}

/* Allocates the buffer and reads the BOD header. */
static unsigned long MallocBuffAndReadBodHeader(WsecHandle readStream, long *remainLen,
    WsecBuff *plainBuff, WsecBuff *cipherBuff, SdpBodCipherHeader *bodHeader)
{
    unsigned long ret;
    WsecUint32 maxCipherBlock = 0;
    WsecBuff plainTemp = { NULL, 0 };
    WsecBuff cipherTemp = { NULL, 0 };
    WsecTlv tlv = { 0, 0, NULL };
    do {
        if (plainBuff->len != KMC_PLAIN_BLOCK_MAX_LEN) {
            WSEC_LOG_E1("invalid cipher file header plainbuff exceed max %u", plainBuff->len);
            ret = WSEC_ERR_FILE_FORMAT;
            break;
        }
        ret = SdpGetCipherDataLen(plainBuff->len, &maxCipherBlock);
        if (ret != WSEC_SUCCESS) {
            break;
        }
        /* Allocate memory. */
        WSEC_BUFF_ALLOC(plainTemp, plainBuff->len);
        WSEC_BUFF_ALLOC(cipherTemp, maxCipherBlock);
        if (plainTemp.buff == NULL) {
            WSEC_LOG_E4MALLOC(plainTemp.len);
            ret = WSEC_ERR_MALLOC_FAIL;
            break;
        }

        if (cipherTemp.buff == NULL) {
            WSEC_LOG_E4MALLOC(cipherTemp.len);
            ret = WSEC_ERR_MALLOC_FAIL;
            break;
        }
        ret = ReadBodHeader(readStream, remainLen, bodHeader, &tlv);
        if (ret != WSEC_SUCCESS) {
            break;
        }
        (void)memcpy_s(plainBuff, sizeof(WsecBuff), &plainTemp, sizeof(WsecBuff));
        (void)memcpy_s(cipherBuff, sizeof(WsecBuff), &cipherTemp, sizeof(WsecBuff));
    } while (0);
    if (ret != WSEC_SUCCESS) {
        WSEC_BUFF_FREE(plainTemp);
        WSEC_BUFF_FREE(cipherTemp);
    }

    return ret;
}

/* File decryption */
static unsigned long FileDecrypt(WsecUint32 domain, WsecHandle readStream, WsecHandle writeStream,
    long remainLen, WsecBuff *plainBuff, const WsecBuff *cipherBuff, const SdpBodCipherHeader *bodHeader)
{
    WsecHandle sdpCtx = NULL;
    WsecTlv tlv = { 0, 0, NULL };
    unsigned long ret;
    WsecUint32 maxPlain = plainBuff->len;
    WsecUint32 maxCipher = cipherBuff->len;

    WsecBuff hmacBuff = { NULL, 0 };
    long remain = remainLen;

    do {
        ret = SdpDecryptInit(domain, &sdpCtx, bodHeader);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E1("SDP_DecryptInit()=%lu", ret);
            break;
        }

        while (remain > 0 && WsecReadTlv(readStream, cipherBuff->buff, cipherBuff->len, &tlv, &ret) == WSEC_TRUE) {
            if (tlv.tag == SDP_CFT_HMAC_VAL) {
                WSEC_BUFF_ASSIGN(hmacBuff, tlv.val, tlv.len);
                break;
            }
            if (tlv.tag != SDP_CFT_CIPHER_BODY) {
                WSEC_LOG_E1("Unexpected TLV's Tag(%u) in the enc file", tlv.tag);
                ret = WSEC_ERR_FILE_FORMAT;
                break;
            }

            /* Decrypting a Ciphertext Segment */
            plainBuff->len = maxPlain;
            ret = SdpDecryptUpdate(&sdpCtx, (const unsigned char *)tlv.val, tlv.len, (unsigned char *)plainBuff->buff, &plainBuff->len);
            /* Check and write the Update result. */
            ret = CheckResultAndWriteIfOk(ret, writeStream, plainBuff);
            if (ret != WSEC_SUCCESS) {
                break;
            }

            ret = SdpSafeSubTwo((WsecUint32)(sizeof(tlv.tag) + sizeof(tlv.len)), tlv.len, &remain);
            if (ret != WSEC_SUCCESS) {
                break;
            }
        }

        plainBuff->len = maxCipher;
        /*
         * The Final interface must be invoked to release the decryption resources
         * regardless of the previous success or failure.
         */
        ret = SdpDecryptFinal(&sdpCtx, (const unsigned char *)hmacBuff.buff, hmacBuff.len, (unsigned char *)plainBuff->buff, &plainBuff->len);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E1("SdpDecryptFinal()=%lu", ret);
            break;
        }
        /* Check the while result and write the final result. */
        ret = CheckResultAndWriteIfOk(ret, writeStream, plainBuff);
    } while (0);
    FreeCipherCtx(&sdpCtx);
    plainBuff->len = maxPlain; // recover plain buffer len
    return ret;
}

/* File decryption function */
unsigned long SdpFileDecrypt(WsecUint32 domain, const char *cipherFile, const char *plainFile,
    const CallbackSetFileDateTime setFileDateTime)
{
    WsecHandle readStream = NULL;
    WsecHandle writeStream = NULL;
    WsecBuff plainBuff = { NULL, 0 };
    WsecBuff cipherBuff = { NULL, 0 };
    SdpCipherFileHeader fileHeader;
    SdpBodCipherHeader bodCipherHeader;
    unsigned long ret;
    long remainLen;

    do {
        (void)memset_s(&fileHeader, sizeof(SdpCipherFileHeader), 0, sizeof(SdpCipherFileHeader));
        ret = WsecReadWriteFilePrepare(cipherFile, plainFile, &readStream, &writeStream, &remainLen);
        if (ret != WSEC_SUCCESS) {
            break;
        }

        /* 1. Ciphertext file detection */
        /* 1.1 Reading the Header of the Ciphertext File */
        ret = ReadFileHeaderEnsurePlainLen(readStream, &fileHeader, &remainLen, &plainBuff);
        if (ret != WSEC_SUCCESS) {
            break;
        }

        ret = MallocBuffAndReadBodHeader(readStream, &remainLen, &plainBuff, &cipherBuff, &bodCipherHeader);
        if (ret != WSEC_SUCCESS) {
            break;
        }

        ret = FileDecrypt(domain, readStream, writeStream, remainLen, &plainBuff, &cipherBuff, &bodCipherHeader);
        if (ret != WSEC_SUCCESS) {
            break;
        }
    } while (0);

    WSEC_FCLOSE(readStream);
    if (WSEC_FFLUSH(writeStream) != 0) {
        WSEC_LOG_E2("SdpFileDecrypt WSEC_FFLUSH failed, errno %d err %lu", WSEC_FERRNO(writeStream), ret);
        ret = WSEC_ERR_FILE_FLUSH_FAIL;
    }
    WSEC_FCLOSE(writeStream);
    WSEC_CLEAR_FREE(plainBuff.buff, fileHeader.plainBlockLenMax);
    WSEC_BUFF_FREE(cipherBuff);

    if (ret == WSEC_SUCCESS) {
        /* Restore the date information of the plaintext file as required. */
        if ((setFileDateTime != NULL) && (WsecIsDateTime(&fileHeader.srcCreateTime) == WSEC_TRUE) &&
            (WsecIsDateTime(&fileHeader.srcEditTime) == WSEC_TRUE)) {
            setFileDateTime(plainFile, &fileHeader.srcCreateTime, &fileHeader.srcEditTime);
        }
    } else {
        /* There is no risk of Face_Condition. */
        WSEC_UNREFER(WSEC_FREMOVE(plainFile));
    }

    return ret;
}

unsigned long SdpGetMkDetailByCipherFile(const char *cipherFile, KmcMkInfo *mkInfo)
{
    SdpBodCipherHeader bodCipherHeader;
    unsigned long ret;
    ret = SdpGetBodCipherHeaderByCipherFile(cipherFile, &bodCipherHeader);
    if (ret != WSEC_SUCCESS) {
        return ret;
    }
    ret = SdpGetMkDetailByBodCipherHeader(&bodCipherHeader, mkInfo);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("SdpGetMkDetailByBod failed.");
    }
    return ret;
}

unsigned long SdpGetBodCipherHeaderByCipherFile(const char *cipherFile, SdpBodCipherHeader *header)
{
    WsecHandle readStream = NULL;
    WsecBuff plainBuff = { NULL, 0};
    SdpCipherFileHeader fileHeader;
    unsigned long ret;
    long remainLen;
    WsecTlv tlv = {0, 0, NULL};

    do {
        if (cipherFile == NULL || header == NULL) {
            ret = WSEC_ERR_INVALID_ARG;
            break;
        }
        (void)memset_s(&fileHeader, sizeof(SdpCipherFileHeader), 0, sizeof(SdpCipherFileHeader));
        if (WsecGetFileLen(cipherFile, &remainLen) == WSEC_FALSE) {
            WSEC_LOG_E("Cannot acess file");
            return WSEC_ERR_OPEN_FILE_FAIL;
        }
        readStream = WSEC_FOPEN(cipherFile, KMC_FILE_READ_BINARY);
        if (readStream == NULL) {
            WSEC_LOG_E("Cannot read file");
            ret = WSEC_ERR_OPEN_FILE_FAIL;
            break;
        }

        /* Reads the ciphertext file header. */
        ret = ReadFileHeaderEnsurePlainLen(readStream, &fileHeader, &remainLen, &plainBuff);
        if (ret != WSEC_SUCCESS) {
            break;
        }

        ret = ReadBodHeader(readStream, &remainLen, header, &tlv);
        if (ret != WSEC_SUCCESS) {
            break;
        }
    } while (0);
    WSEC_FCLOSE(readStream);
    readStream = NULL;
    return ret;
}

static unsigned long CheckSdpCipherHeader(const SdpCipherHeader *header)
{
    if (header->version != SDP_CIPHER_TEXT_VER1) {
        WSEC_LOG_E2("[SDP] Ciphertext version expect %u actually %u.", SDP_CIPHER_TEXT_VER1, header->version);
        return WSEC_ERR_SDP_VERSION_INCOMPATIBLE;
    }
    if (header->hmacFlag != WSEC_TRUE && header->hmacFlag != WSEC_FALSE) {
        WSEC_LOG_E("[SDP] Hmac flag out of bounds.");
        return WSEC_ERR_SDP_INVALID_CIPHER_TEXT;
    }
    if (header->iter != KMC_WORK_KEY_ITER_COUNT) {
        WSEC_LOG_E("[SDP] Iterator count out of bounds.");
        return WSEC_ERR_SDP_INVALID_CIPHER_TEXT;
    }

    if (CheckIsSymAlg(header->algId) != WSEC_TRUE) {
        return WSEC_ERR_SDP_INVALID_CIPHER_TEXT;
    }
    return WSEC_SUCCESS;
}

unsigned long SdpGetCipherHeaderV1(const unsigned char *ciphertext, WsecUint32 ciphertextLen,
    SdpCipherHeader *cipherHeader)
{
    WsecUint32 headerLen = sizeof(SdpCipherHeader);
    SdpCipherHeader header;
    unsigned long returnValue;
    if ((ciphertext == NULL) || (cipherHeader == NULL)) {
        WSEC_LOG_E2("%s - %d, parameter invalid.", __FUNCTION__, __LINE__);
        return WSEC_ERR_INVALID_ARG;
    }
    if (ciphertextLen < headerLen) {
        WSEC_LOG_E2("[SDP] SDPV1 cipher header length should be %u, but %u.", headerLen, ciphertextLen);
        return WSEC_ERR_SDP_CIPHER_LENGTH_NOT_ENOUGH;
    }

    if (memcpy_s(&header, sizeof(SdpCipherHeader), ciphertext, sizeof(SdpCipherHeader)) != EOK) {
        WSEC_LOG_E4MEMCPY;
        return WSEC_ERR_MEMCPY_FAIL;
    }
    /* Convert the byte order. */
    SdpCvtSdpCipherHeaderByteOrder(&header, WBCNETWORK2HOST);
    /* check head */
    returnValue = CheckSdpCipherHeader(&header);
    if (returnValue != WSEC_SUCCESS) {
        return returnValue;
    }
    if (memcpy_s(cipherHeader, sizeof(SdpCipherHeader), &header, sizeof(SdpCipherHeader)) != EOK) {
        WSEC_LOG_E4MEMCPY;
        return WSEC_ERR_MEMCPY_FAIL;
    }

    return returnValue;
}

unsigned long SdpGetMkDetailByBodCipherHeader(SdpBodCipherHeader *bodCipherHeader, KmcMkInfo *mkInfo)
{
    SdpCipherHeader header;
    unsigned long ret;
    WsecUint32 keyBuffLen;
    unsigned char keyPlaintextBuff[SDP_KEY_MAX_LEN] = {0};
    keyBuffLen = SDP_KEY_MAX_LEN;

    if (bodCipherHeader == NULL || mkInfo == NULL) {
        WSEC_LOG_E2("%s - %d, parameter invalid.", __FUNCTION__, __LINE__);
        return WSEC_ERR_INVALID_ARG;
    }

    if (memcpy_s(&header, sizeof(SdpCipherHeader), &bodCipherHeader->cipherBuff, sizeof(SdpCipherHeader)) != EOK) {
        WSEC_LOG_E4MEMCPY;
        return WSEC_ERR_MEMCPY_FAIL;
    }
    /* Byte order conversion */
    SdpCvtSdpCipherHeaderByteOrder(&header, WBCNETWORK2HOST);

    /* check head */
    ret = CheckSdpCipherHeader(&header);
    if (ret != WSEC_SUCCESS) {
        return ret;
    }

    ret = KmcGetMkDetail(header.domain, header.keyId, mkInfo, keyPlaintextBuff, &keyBuffLen);
    (void)memset_s(keyPlaintextBuff, sizeof(keyPlaintextBuff), 0, sizeof(keyPlaintextBuff));
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E3("%s - %d, Get the KmcMkInfo failed %lu.", __FUNCTION__, __LINE__, ret);
    }
    return ret;
}

/* Preparing for Stream Data Encryption */
static unsigned long SdpEncryptInitPrepare(WsecHandle *ctx,
    SdpBodCipherHeader *bodCipherHeader, SdpCipherCtx **sdpCtx, SdpCipherHeader **cipherHeader)
{
    SdpCipherCtx *temp = NULL;
    unsigned long ret;
    WSEC_ASSERT(sdpCtx != NULL);
    WSEC_ASSERT(cipherHeader != NULL);

    /* Check the input parameters. */
    if (ctx == NULL || bodCipherHeader == NULL) {
        return WSEC_ERR_INVALID_ARG;
    }

    ret = CheckKsfV1();
    if (ret != WSEC_SUCCESS) {
        return ret;
    }

    /* Construct the context. */
    temp = (SdpCipherCtx *)WSEC_MALLOC(SDP_CIPHER_CTX_LEN);
    if (temp == NULL) {
        WSEC_LOG_E("[SDP] Memory for context allocate failed encrypt");
        return WSEC_ERR_MALLOC_FAIL;
    }
    *ctx = temp;
    *sdpCtx = temp;
    *cipherHeader = &(temp->cipherHeader);
    /* Ciphertext header */
    (void)memset_s(bodCipherHeader, sizeof(SdpBodCipherHeader), 0, sizeof(SdpBodCipherHeader));
    return WSEC_SUCCESS;
}

static unsigned long DoSdpHmacInit(WsecUint32 domain, WsecUint32 hmacAlgId,
    SdpBodCipherHeader *bodCipherHeader, SdpCipherCtx *sdpCtx)
{
    WSEC_ASSERT(sdpCtx != NULL);
    WSEC_ASSERT(bodCipherHeader != NULL);
    unsigned long ret;
    ret = SdpGetHmacAlgAttr(domain, hmacAlgId, &bodCipherHeader->hmacBuff);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E1("SdpGetHmacAlgAttr() = %lu.", ret);
        return ret;
    }

    ret = SdpHmacInit(domain, &bodCipherHeader->hmacBuff, &sdpCtx->hmacCtx);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] SDP HMAC calculation init failed.");
        return ret;
    }
    return WSEC_SUCCESS;
}

/* Stream Data Encryption - Start, support AES-GCM from KMC 3.1.1.B001 */
unsigned long SdpEncryptInit(WsecUint32 domain, WsecUint32 cipherAlgId, WsecUint32 hmacAlgId,
    WsecHandle *ctx, SdpBodCipherHeader *bodCipherHeader)
{
    SdpCipherCtx *sdpCtx = NULL;
    SdpCipherHeader *cipherHeader = NULL;
    unsigned char key[SDP_KEY_MAX_LEN] = {0};
    unsigned long ret;
    WsecUint32 keyLen = sizeof(key);
    WsecUint32 ivLen = 0;
    SdpHeaderId ids = { DEFAULT_SDP_DOMAIN_ID, WSEC_ALGID_UNKNOWN, WSEC_FALSE, WSEC_ALGID_UNKNOWN };
    FillSdpHeaderId(&ids, domain, cipherAlgId, hmacAlgId);

    ret = SdpEncryptInitPrepare(ctx, bodCipherHeader, &sdpCtx, &cipherHeader);
    if (ret != WSEC_SUCCESS) {
        return ret;
    }

    do {
        /* Construct the ciphertext header of the V1 version. */
        ret = SdpFillCipherTextHeader(ids, cipherHeader, key, &keyLen, &ivLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E("[SDP] Fill cipher text header failed.");
            break;
        }

        /* Encrypting Init */
        ret = CacEncryptInit(&(sdpCtx->cacCtx), cipherHeader->algId, key, keyLen, cipherHeader->iv, ivLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E1("[SDP] CAC encrypt init failed %lu.", ret);
            ret = WSEC_ERR_ENCRPT_FAIL;
            break;
        }
        /* Updating the Ciphertext Length */
        cipherHeader->cipherLen = 0u;

        /* Output ciphertext header */
        if (memcpy_s(&bodCipherHeader->cipherBuff, sizeof(bodCipherHeader->cipherBuff),
            cipherHeader, sizeof(SdpCipherHeader)) != EOK) {
            ret = WSEC_ERR_MEMCPY_FAIL;
            break;
        }

        /* Calculate HMAC */
        if ((CheckIsGcmAlgId(cipherHeader->algId) == WSEC_FALSE) && (cipherHeader->hmacFlag)) {
            ret = DoSdpHmacInit(domain, hmacAlgId, bodCipherHeader, sdpCtx);
            if (ret != WSEC_SUCCESS) {
                WSEC_LOG_E1("[SDP] DoSdpHmacInit failed %lu.", ret);
                break;
            }
        }
        /* Convert to network sequence */
        SdpCvtSdpCipherHeaderByteOrder(&(bodCipherHeader->cipherBuff.cipherHeader), WBCHOST2NETWORK);
    } while (0);

    /* Destroys a memory key. */
    (void)memset_s(key, sizeof(key), 0, sizeof(key));

    if (ret != WSEC_SUCCESS) {
        FreeCipherCtx(ctx);
    }

    return ret;
}

/* Stream Data Encryption-Add. If input param invalid, ctx will be released. */
unsigned long SdpEncryptUpdate(WsecHandle *ctx, const unsigned char *plainText, WsecUint32 plainLen,
    unsigned char *cipherText, WsecUint32 *cipherLen)
{
    SdpCipherCtx *sdpCtx = NULL;
    SdpCipherHeader *cipherHeader = NULL;
    unsigned long ret;
    WsecUint32 tempCipherLen;
    /* Check the input parameters. */
    if (ctx == NULL || (*ctx == NULL) || plainText == NULL || plainLen == 0 || cipherText == NULL ||
        cipherLen == NULL || (*cipherLen < plainLen) || plainText == cipherText) {
        FreeCipherCtx(ctx);
        return WSEC_ERR_INVALID_ARG;
    }

    tempCipherLen = *cipherLen;
    do {
        /* Construct the context. */
        sdpCtx = (SdpCipherCtx *)(*ctx);
        cipherHeader = &(sdpCtx->cipherHeader);

        /* Encrypting Update */
        ret = CacEncryptUpdate(sdpCtx->cacCtx, plainText, plainLen, cipherText, &tempCipherLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E1("[SDP] CAC encrypt update failed %lu.", ret);
            ret = WSEC_ERR_ENCRPT_FAIL;
            break;
        }

        /* Updating the Ciphertext Length */
        cipherHeader->cipherLen += tempCipherLen;

        /* Calculate HMAC */
        if ((CheckIsGcmAlgId(cipherHeader->algId) == WSEC_FALSE) && (cipherHeader->hmacFlag)) {
            ret = SdpHmacUpdate(&(sdpCtx->hmacCtx), plainText, plainLen);
            if (ret != WSEC_SUCCESS) {
                WSEC_LOG_E("[SDP] SDP HMAC calculation update failed.");
                break;
            }
        }

        /* Output Length */
        *cipherLen = tempCipherLen;
    } while (0);

    if (ret != WSEC_SUCCESS) {
        FreeCipherCtx(ctx);
    }
    return ret;
}

static WsecBool CheckInputParamForFinal(SdpCipherHeader *cipherHeader,
    const unsigned char *hmacText, WsecBool hmacLenValid, const unsigned char *inBuff, const WsecUint32 *inLen)
{
    if (CheckIsSymAlg(cipherHeader->algId) == WSEC_FALSE) {
        WSEC_LOG_E("[SDP] cipherAlgId in header error.");
        return WSEC_FALSE;
    }

    /* AES-CBC, input buffer pointer must be non-Null */
    if ((CheckIsCbcAlgId(cipherHeader->algId) == WSEC_TRUE) && (inBuff == NULL || inLen == NULL)) {
        WSEC_LOG_E("[SDP] Invalid parameter, non-Null buffer pointer expected.");
        return WSEC_FALSE;
    }

    /* AES-GCM or AES-CBC with hmac, hmac pointer must be non-Null */
    if (((CheckIsGcmAlgId(cipherHeader->algId) == WSEC_TRUE) || (cipherHeader->hmacFlag)) &&
        ((hmacText == NULL) || (hmacLenValid == WSEC_FALSE))) {
        WSEC_LOG_E("[SDP] Invalid parameter, non-Null HMAC pointer expected.");
        return WSEC_FALSE;
    }
    return WSEC_TRUE;
}

static unsigned long DoEncryptAesCbcFinal(WsecHandle *ctx, unsigned char *cipherText, WsecUint32 *cipherLen,
    unsigned char *hmacText, WsecUint32 *hmacLen)
{
    unsigned long ret;
    SdpCipherCtx *sdpCtx = NULL;
    SdpCipherHeader *cipherHeader = NULL;
    WsecUint32 tempCipherLen = *cipherLen;
    WsecUint32 tempMacLen;
    sdpCtx = (SdpCipherCtx *)(*ctx);
    cipherHeader = &(sdpCtx->cipherHeader);
    /* Encrypt the final. */
    ret = CacEncryptFinal(&(sdpCtx->cacCtx), cipherText, &tempCipherLen);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] CAC encrypt final failed.");
        return WSEC_ERR_ENCRPT_FAIL;
    }

    /* Updating the Ciphertext Length */
    cipherHeader->cipherLen += tempCipherLen;
    /* if use AES-CBC without hmac, hmacLen will be 0 */
    if (hmacLen != NULL) {
        tempMacLen = *hmacLen;
        *hmacLen = 0;
    }
    /* Calculate HMAC */
    if (cipherHeader->hmacFlag && hmacLen != NULL) {
        ret = SdpHmacFinal(&(sdpCtx->hmacCtx), hmacText, &tempMacLen);
        if (ret != WSEC_SUCCESS) {
            return ret;
        }
        *hmacLen = tempMacLen;
    }

    /* Output Length */
    *cipherLen = tempCipherLen;
    return ret;
}

/* Stream Data Encryption - Termination. If input param invalid, ctx will be released. */
unsigned long SdpEncryptFinal(WsecHandle *ctx, unsigned char *cipherText, WsecUint32 *cipherLen,
    unsigned char *hmacText, WsecUint32 *hmacLen)
{
    SdpCipherCtx *sdpCtx = NULL;
    SdpCipherHeader *cipherHeader = NULL;
    unsigned long ret;
    WsecUint32 tempMacLen;
    WsecBool hmacLenValid = (hmacLen != NULL);
    /* Check the input parameters. */
    if (ctx == NULL || (*ctx) == NULL) {
        return WSEC_ERR_INVALID_ARG;
    }

    do {
        /* Construct the context. */
        sdpCtx = (SdpCipherCtx *)(*ctx);
        cipherHeader = &(sdpCtx->cipherHeader);
        if (CheckInputParamForFinal(cipherHeader, hmacText, hmacLenValid, cipherText, cipherLen) == WSEC_FALSE) {
            ret = WSEC_ERR_INVALID_ARG;
            break;
        }

        if (CheckIsGcmAlgId(cipherHeader->algId) == WSEC_TRUE) {
            tempMacLen = *hmacLen;
            ret = CacEncryptFinal(&(sdpCtx->cacCtx), hmacText, &tempMacLen);
            if (ret != WSEC_SUCCESS) {
                WSEC_LOG_E("[SDP] CAC encrypt final failed.");
                ret = WSEC_ERR_ENCRPT_FAIL;
                break;
            }
            if (cipherLen != NULL) {
                *cipherLen = 0;
            }
            *hmacLen = tempMacLen;
            break;
        }
        ret = DoEncryptAesCbcFinal(ctx, cipherText, cipherLen, hmacText, hmacLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E("[SDP] DoDecryptAesCbcFinal failed.");
            break;
        }
    } while (0);
    FreeCipherCtx(ctx);
    return ret;
}

/* Verify the ciphertext header. */
static unsigned long CheckSdpCipherHeaderForDec(WsecUint32 domain, const SdpCipherHeader *header)
{
    if (domain != header->domain) {
        WSEC_LOG_E1("[SDP] Cipher header invalid with unexpected domain %u.", header->domain);
        return WSEC_ERR_SDP_DOMAIN_UNEXPECTED;
    }

    return CheckSdpCipherHeader(header);
}

/* Preparing for Data Decryption */
static unsigned long SdpDecryptInitPrepare(WsecUint32 domain,
    WsecHandle *ctx,
    const SdpBodCipherHeader *bodHeader,
    SdpCipherCtx **sdpCtx,
    SdpCipherHeader **header)
{
    unsigned long ret;
    SdpCipherCtx *temp = NULL;
    SdpCipherHeader *newHead = NULL;
    /* Check the input parameters. */
    if (ctx == NULL || bodHeader == NULL) {
        return WSEC_ERR_INVALID_ARG;
    }

    ret = CheckKsfV1();
    if (ret != WSEC_SUCCESS) {
        return ret;
    }

    /* Construct the context. */
    temp = (SdpCipherCtx *)WSEC_MALLOC(SDP_CIPHER_CTX_LEN);
    if (temp == NULL) {
        WSEC_LOG_E("[SDP] Decrypt cipher context allocate failed.");
        return WSEC_ERR_MALLOC_FAIL;
    }
    newHead = &(temp->cipherHeader);

    do {
        if (memcpy_s(newHead, sizeof(SdpCipherHeader), &bodHeader->cipherBuff, sizeof(SdpCipherHeader)) != EOK) {
            ret = WSEC_ERR_MEMCPY_FAIL;
            break;
        }

        /* Convert to host order */
        SdpCvtSdpCipherHeaderByteOrder(newHead, WBCNETWORK2HOST);
        /* check head */
        ret = CheckSdpCipherHeaderForDec(domain, newHead);
        if (ret != WSEC_SUCCESS) {
            break;
        }
        /* The value of this field is 0 in the BOD during encryption. Therefore, the value must also be 0. */
        if (newHead->cipherLen != 0) {
            WSEC_LOG_E1("[SDP] Cipher len invalid %u.", newHead->cipherLen);
            ret = WSEC_ERR_SDP_INVALID_CIPHER_TEXT;
            break;
        }
    } while (0);
    if (ret != WSEC_SUCCESS) {
        WSEC_FREE(temp);
        newHead = NULL;
    }
    *ctx = temp;
    *sdpCtx = temp;
    *header = newHead;
    return ret;
}

/* Stream data decryption-start */
unsigned long SdpDecryptInit(WsecUint32 domain, WsecHandle *ctx, const SdpBodCipherHeader *bodCipherHeader)
{
    SdpCipherCtx *sdpCtx = NULL;
    SdpCipherHeader *cipherHeader = NULL;
    WsecUint32 algType = WSEC_ALGTYPE_UNKNOWN;
    unsigned char key[SDP_KEY_MAX_LEN] = {0};
    unsigned long ret;
    WsecUint32 keyLen = 0;
    WsecUint32 ivLen = 0;

    /* Check the input parameters. */
    ret = SdpDecryptInitPrepare(domain, ctx, bodCipherHeader, &sdpCtx, &cipherHeader);
    if (ret != WSEC_SUCCESS) {
        return ret;
    }

    do {
        /* Obtain the key length, IV, and MAC length. */
        ret = SdpGetAlgPropertyEx(cipherHeader->algId, &algType, &keyLen, &ivLen, NULL);
        if (ret != WSEC_SUCCESS) {
            break;
        }

        /* Obtains the working key based on keyId. */
        ret = GetWorkKeyByID(cipherHeader->domain, cipherHeader->keyId, cipherHeader->iter,
            cipherHeader->salt, SDP_SALT_LEN, key, keyLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E1("[SDP] KMC get WK by keyId failed %lu.", ret);
            break;
        }

        /* Decrypting Init */
        ret = CacDecryptInit(&(sdpCtx->cacCtx), cipherHeader->algId, key, keyLen, cipherHeader->iv, ivLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E("[SDP] CAC decrypt init failed.");
            ret = WSEC_ERR_DECRPT_FAIL;
            break;
        }

        /* Verifying the HMAC */
        if ((CheckIsGcmAlgId(cipherHeader->algId) == WSEC_FALSE) && (cipherHeader->hmacFlag)) {
            ret = SdpHmacInit(domain, &bodCipherHeader->hmacBuff, &sdpCtx->hmacCtx);
            if (ret != WSEC_SUCCESS) {
                WSEC_LOG_E1("[SDP] Cipher text hmac verify init failed %lu.", ret);
                break;
            }
        }
    } while (0);

    /* Destroys a memory key. */
    (void)memset_s(key, sizeof(key), 0, sizeof(key));

    if (ret != WSEC_SUCCESS) {
        FreeCipherCtx(ctx);
    }
    return ret;
}

/* Stream Data Decryption-Add. If input param invalid, ctx will be released. */
unsigned long SdpDecryptUpdate(WsecHandle *ctx, const unsigned char *cipherText, WsecUint32 cipherLen,
    unsigned char *plainText, WsecUint32 *plainLen)
{
    SdpCipherCtx *sdpCtx = NULL;
    SdpCipherHeader *cipherHeader = NULL;
    unsigned long ret;
    WsecUint32 tempPlainLen;
    /* Check the input parameters. */
    if (ctx == NULL || (*ctx) == NULL || cipherText == NULL || cipherLen == 0 ||
        plainText == NULL || plainLen == NULL || plainText == cipherText) {
        FreeCipherCtx(ctx);
        return WSEC_ERR_INVALID_ARG;
    }

    tempPlainLen = *plainLen;
    do {
        /* Construct the context. */
        sdpCtx = (SdpCipherCtx *)(*ctx);
        cipherHeader = &(sdpCtx->cipherHeader);

        /* Decrypting Update */
        ret = CacDecryptUpdate(sdpCtx->cacCtx, cipherText, cipherLen, plainText, &tempPlainLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E("[SDP] CAC decrypt update failed.");
            ret = WSEC_ERR_DECRPT_FAIL;
            break;
        }

        /* Verifying the HMAC */
        if ((CheckIsGcmAlgId(cipherHeader->algId) == WSEC_FALSE) && (cipherHeader->hmacFlag) && (tempPlainLen > 0)) {
            ret = SdpHmacUpdate(&sdpCtx->hmacCtx, plainText, tempPlainLen);
            if (ret != WSEC_SUCCESS) {
                WSEC_LOG_E("[SDP] Cipher text hmac verify update failed.");
                break;
            }
        }

        /* Output Length */
        *plainLen = tempPlainLen;
    } while (0);

    if (ret != WSEC_SUCCESS) {
        FreeCipherCtx(ctx);
    }

    return ret;
}

static unsigned long DoDecryptAesGcmFinal(const WsecHandle *ctx, const unsigned char *hmacText, WsecUint32 hmacLen)
{
    WSEC_ASSERT(ctx != NULL);
    WSEC_ASSERT((*ctx) != NULL);
    WSEC_ASSERT(hmacText != NULL);
    unsigned long ret;
    SdpCipherCtx *sdpCtx = NULL;
    unsigned char tag[WSEC_AES_GCM_TAGLEN] = {0};
    WsecUint32 tagLen = WSEC_AES_GCM_TAGLEN;
    sdpCtx = (SdpCipherCtx *)(*ctx);
    /* AES-GCM tag len is WSEC_AES_GCM_TAGLEN */
    if (hmacLen < WSEC_AES_GCM_TAGLEN) {
        WSEC_LOG_E2("[SDP] SdpDecryptFinal tag buffer expect %u but %u.", WSEC_AES_GCM_TAGLEN, hmacLen);
        return WSEC_ERR_INVALID_ARG;
    }
    if (memcpy_s(tag, WSEC_AES_GCM_TAGLEN, hmacText, hmacLen) != EOK) {
        WSEC_LOG_E4MEMCPY;
        return WSEC_ERR_MEMCPY_FAIL;
    }
    ret = CacDecryptFinal(&(sdpCtx->cacCtx), tag, &tagLen);
    if (ret != WSEC_SUCCESS) {
        (void)memset_s(tag, sizeof(tag), 0, sizeof(tag));
        WSEC_LOG_E1("[SDP] CAC decrypt final failed %lu.", ret);
        return WSEC_ERR_DECRPT_FAIL;
    }
    (void)memset_s(tag, sizeof(tag), 0, sizeof(tag));
    return WSEC_SUCCESS;
}

static unsigned long DoDecryptAesCbcFinal(const WsecHandle *ctx, const unsigned char *hmacText, WsecUint32 hmacLen,
    unsigned char *plainText, WsecUint32 *plainLen)
{
    SdpCipherCtx *sdpCtx = NULL;
    SdpCipherHeader *cipherHeader = NULL;
    unsigned long ret;
    unsigned char hmac[WSEC_HMAC_LEN_MAX] = {0};
    WsecUint32 macLen = (WsecUint32)sizeof(hmac);
    WsecUint32 tempPlainLen = *plainLen;
    sdpCtx = (SdpCipherCtx *)(*ctx);
    cipherHeader = &(sdpCtx->cipherHeader);
    /* Decrypt the final file. */
    ret = CacDecryptFinal(&(sdpCtx->cacCtx), plainText, &tempPlainLen);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E1("[SDP] CAC decrypt final failed %lu.", ret);
        return WSEC_ERR_DECRPT_FAIL;
    }
    if (cipherHeader->hmacFlag) {
        /* update hamc of remain plaintext */
        if (tempPlainLen > 0) {
            ret = SdpHmacUpdate(&sdpCtx->hmacCtx, plainText, tempPlainLen);
            if (ret != WSEC_SUCCESS) {
                WSEC_LOG_E("[SDP] Cipher text hmac verify update failed.");
                return ret;
            }
        }

        ret = SdpHmacFinal(&sdpCtx->hmacCtx, hmac, &macLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E1("[SDP] Cipher text hmac verify final failed %lu.", ret);
            return ret;
        }

        if (macLen != hmacLen || WSEC_MEMCMP(hmac, hmacText, hmacLen) != 0) {
            WSEC_LOG_E2("Verify hmac failed for HMAC is not same, calc len %u in len %u.", macLen, hmacLen);
            return WSEC_ERR_HMAC_AUTH_FAIL;
        }
    }
    *plainLen = tempPlainLen;
    return ret;
}

/* Stream data decryption-termination. If input param invalid, ctx will be released. */
unsigned long SdpDecryptFinal(WsecHandle *ctx, const unsigned char *hmacText, WsecUint32 hmacLen,
    unsigned char *plainText, WsecUint32 *plainLen)
{
    SdpCipherCtx *sdpCtx = NULL;
    SdpCipherHeader *cipherHeader = NULL;
    unsigned long ret;
    WsecBool hmacLenValid = (hmacLen != 0);
    /* Check the input parameters. */
    if (ctx == NULL || (*ctx) == NULL) {
        return WSEC_ERR_INVALID_ARG;
    }

    /* Construct the context. */
    sdpCtx = (SdpCipherCtx *)(*ctx);
    cipherHeader = &(sdpCtx->cipherHeader);

    do {
        if (CheckInputParamForFinal(cipherHeader, hmacText, hmacLenValid, plainText, plainLen) == WSEC_FALSE) {
            ret = WSEC_ERR_INVALID_ARG;
            break;
        }

        if (CheckIsGcmAlgId(cipherHeader->algId) == WSEC_TRUE) {
            ret = DoDecryptAesGcmFinal(ctx, hmacText, hmacLen);
            if (ret != WSEC_SUCCESS) {
                break;
            }
            if (plainLen != NULL) {
                *plainLen = 0;
            }
            break;
        }

        ret = DoDecryptAesCbcFinal(ctx, hmacText, hmacLen, plainText, plainLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E("[SDP] DoDecryptAesCbcFinal failed.");
            break;
        }
    } while (0);
    FreeCipherCtx(ctx);
    return ret;
}

/* The encryption preparation includes checking the input parameter and obtaining the maximum ciphertext length. */
static unsigned long SdpEncryptPrepare(const unsigned char *plainText, WsecUint32 plainLen,
    unsigned char *cipherText, const WsecUint32 *cipherLen, WsecUint32 *maxCipherLen)
{
    unsigned long ret;
    WSEC_ASSERT(maxCipherLen != NULL);
    /* Check the input parameters. */
    if (plainText == NULL || cipherText == NULL || cipherLen == NULL || plainText == cipherText) {
        WSEC_LOG_E2("%s - %d, parameter invalid.", __FUNCTION__, __LINE__);
        return WSEC_ERR_INVALID_ARG;
    }

    ret = CheckKsfV1();
    if (ret != WSEC_SUCCESS) {
        return ret;
    }

    ret = SdpGetCipherDataLen(plainLen, maxCipherLen);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] Buffer input of plaintext is wrong .");
        return ret;
    }
    if (*cipherLen < *maxCipherLen) {
        WSEC_LOG_E1("[SDP] Ciphertext buffer is not enough, ciphertextLen %u.", *cipherLen);
        return WSEC_ERR_OUTPUT_BUFF_NOT_ENOUGH;
    }

    /* Construct a header to obtain the working key. */
    (void)memset_s(cipherText, (size_t)(*maxCipherLen), 0, (size_t)(*maxCipherLen));
    return WSEC_SUCCESS;
}


/* Small-size data encryption */
unsigned long SdpEncrypt(WsecUint32 domain, WsecUint32 cipherAlgId, WsecUint32 hmacAlgId,
    const unsigned char *plainText, WsecUint32 plainLen, unsigned char *cipherText, WsecUint32 *cipherLen)
{
    SdpCipherHeader *cipherHeader = NULL;
    unsigned char key[SDP_KEY_MAX_LEN] = {0};
    unsigned long ret;
    WsecUint32 keyLen = sizeof(key);
    WsecUint32 ivLen = 0;
    WsecUint32 macLen;
    WsecUint32 tempCipherLen;
    WsecUint32 maxCipherLen = 0;
    SdpHeaderId ids = { DEFAULT_SDP_DOMAIN_ID, WSEC_ALGID_UNKNOWN, WSEC_FALSE, WSEC_ALGID_UNKNOWN };
    FillSdpHeaderId(&ids, domain, cipherAlgId, hmacAlgId);

    /* V1 does not support AES-GCM. */
    if (CheckIsGcmAlgId(cipherAlgId) == WSEC_TRUE) {
        return WSEC_ERR_SDP_ALG_NOT_SUPPORTED;
    }
    ret = SdpEncryptPrepare(plainText, plainLen, cipherText, cipherLen, &maxCipherLen);
    if (ret != WSEC_SUCCESS) {
        return ret;
    }

    cipherHeader = (SdpCipherHeader *)(WsecVoid *)cipherText;
    ret = SdpFillCipherTextHeader(ids, cipherHeader, key, &keyLen, &ivLen);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] Fill cipher text header failed.");
        return ret;
    }
    maxCipherLen -= SDP_CIPHER_HEAD_LEN;    /* soter 554 */
    tempCipherLen = maxCipherLen;

    /* Encryption */
    ret = CacEncrypt(cipherHeader->algId, key, keyLen, cipherHeader->iv, ivLen,
        plainText, plainLen, (cipherText + SDP_CIPHER_HEAD_LEN), &tempCipherLen);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] CAC encrypt failed.");
        /* Destroys a memory key. */
        (void)memset_s(key, sizeof(key), 0, sizeof(key));
        return WSEC_ERR_ENCRPT_FAIL;
    }

    /* Destroys a memory key. */
    (void)memset_s(key, sizeof(key), 0, sizeof(key));

    maxCipherLen -= tempCipherLen;  /* soter 554 */

    /* Updating the Ciphertext Length */
    cipherHeader->cipherLen = tempCipherLen;

    /* Calculate the length of the output ciphertext. */
    tempCipherLen += SDP_CIPHER_HEAD_LEN;

    /* Calculate HMAC */
    if (cipherHeader->hmacFlag) {
        macLen = maxCipherLen;
        ret = SdpHmac(domain, hmacAlgId, plainText, plainLen, cipherText + tempCipherLen, &macLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E("[SDP] Compute hmac failed.");
            return ret;
        }

        tempCipherLen += macLen;
    }

    /* Convert to network sequence */
    SdpCvtSdpCipherHeaderByteOrder(cipherHeader, WBCHOST2NETWORK);

    /* Output Length */
    *cipherLen = tempCipherLen;

    return WSEC_SUCCESS;
}

/* Decryption Preparations */
static unsigned long SdpDecryptPrepare(WsecUint32 domain, const WsecBuffConst *cipherBuff,
    const unsigned char *plainText, const WsecUint32 *plainLen,
    WsecUint32 *keyLen, WsecUint32 *ivLen, SdpCipherHeader **header)
{
    SdpCipherHeader *temp = NULL;
    WsecUint32 algType = WSEC_ALGTYPE_UNKNOWN;
    unsigned long ret;
    WsecUint32 keyLength = 0;
    WsecUint32 ivLength = 0;

    /* Check the input parameters. */
    WSEC_ASSERT(cipherBuff != NULL);
    if (cipherBuff->buff == NULL || cipherBuff->len < SDP_CIPHER_HEAD_LEN ||
        plainText == NULL || plainLen == NULL || plainText == cipherBuff->buff) {
        return WSEC_ERR_INVALID_ARG;
    }

    temp = (SdpCipherHeader *)WSEC_MALLOC(sizeof(SdpCipherHeader));
    if (temp == NULL) {
        WSEC_LOG_E("[SDP] Memory for cipher head allocation failed.");
        return WSEC_ERR_MALLOC_FAIL;
    }

    do {
        if (memcpy_s(temp, sizeof(SdpCipherHeader), cipherBuff->buff, sizeof(SdpCipherHeader)) != EOK) {
            WSEC_LOG_E4MEMCPY;
            ret = WSEC_ERR_MEMCPY_FAIL;
            break;
        }

        /* Convert to host order */
        SdpCvtSdpCipherHeaderByteOrder(temp, WBCNETWORK2HOST);
        ret = CheckSdpCipherHeaderForDec(domain, temp);
        if (ret != WSEC_SUCCESS) {
            break;
        }
        /*
         * In this encryption mode, this field is filled with the actual ciphertext length.
         * Therefore, this field cannot be set to 0.
         */
        if (temp->cipherLen == 0 || cipherBuff->len < (SDP_CIPHER_HEAD_LEN + temp->cipherLen)) {
            WSEC_LOG_E2("[SDP] Cipher data length is invalid %u %u", temp->cipherLen, cipherBuff->len);
            ret = WSEC_ERR_SDP_INVALID_CIPHER_TEXT;
            break;
        }

        /* Obtain the key length, IV, and MAC length. */
        ret = SdpGetAlgPropertyEx(temp->algId, &algType, &keyLength, &ivLength, NULL);
        if (ret != WSEC_SUCCESS) {
            break;
        }
        if (algType != WSEC_ALGTYPE_SYM) {
            WSEC_LOG_E1("[SDP] algType(%u) is out of bounds.", algType);
            ret = WSEC_ERR_SDP_INVALID_CIPHER_TEXT;
            break;
        }
    } while (0);

    if (ret != WSEC_SUCCESS) {
        WSEC_FREE(temp);
    }
    *header = temp;
    *keyLen = keyLength;
    *ivLen = ivLength;
    return ret;
}

/* Small data decryption */
unsigned long SdpDecrypt(WsecUint32 domain, const unsigned char *cipherText, WsecUint32 cipherLen,
    unsigned char *plainText, WsecUint32 *plainLen)
{
    SdpCipherHeader *cipherHeader = NULL;
    unsigned char key[SDP_KEY_MAX_LEN] = {0};
    unsigned long ret = CheckKsfV1();
    WsecUint32 keyLen = 0;
    WsecUint32 ivLen = 0;
    WsecUint32 tempPlainLen;
    WsecBuffConst cipherBuff;
    WSEC_BUFF_ASSIGN(cipherBuff, cipherText, cipherLen);
    if (ret != WSEC_SUCCESS) {
        return ret;
    }
    ret = SdpDecryptPrepare(domain, &cipherBuff, plainText, plainLen, &keyLen, &ivLen, &cipherHeader);
    if (ret != WSEC_SUCCESS) {
        return ret;
    }
    tempPlainLen = *plainLen;
    do {
        /* Obtains the working key based on keyId. */
        if ((ret = GetWorkKeyByID(cipherHeader->domain, cipherHeader->keyId, cipherHeader->iter,
            cipherHeader->salt, SDP_SALT_LEN, key, keyLen)) != WSEC_SUCCESS) {
            WSEC_LOG_E("[SDP] Get WK by key id failed.");
            break;
        }
        /* Decryption */
        if (tempPlainLen < cipherHeader->cipherLen) {
            WSEC_LOG_E2("Plain-Buff size(%u) at least is %u", tempPlainLen, cipherHeader->cipherLen);
            ret = WSEC_ERR_OUTPUT_BUFF_NOT_ENOUGH;
            break;
        }
        ret = CacDecrypt(cipherHeader->algId, key, keyLen, cipherHeader->iv, ivLen,
            (cipherText + SDP_CIPHER_HEAD_LEN), cipherHeader->cipherLen, plainText, &tempPlainLen);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E("[SDP] CAC decrypt failed.");
            ret = WSEC_ERR_DECRPT_FAIL;
            break;
        }
        /* Verifying the HMAC */
        if (cipherHeader->hmacFlag) {
            ret = SdpVerifyHmac(domain, plainText, tempPlainLen,
                (cipherText + SDP_CIPHER_HEAD_LEN + cipherHeader->cipherLen),
                ((cipherLen - SDP_CIPHER_HEAD_LEN) - cipherHeader->cipherLen));     /* soter 554 */
            if (ret != WSEC_SUCCESS) {
                WSEC_LOG_E("[SDP] Cipher text hmac verify failed.");
                break;
            }
        }

        /* Output Length */
        *plainLen = tempPlainLen;
    } while (0);

    /* Destroys a memory key. */
    (void)memset_s(key, sizeof(key), 0, sizeof(key));
    WSEC_FREE(cipherHeader);

    return ret;
}

/* Length of the password protection result. The input is the password hash length. */
size_t SdpGetPwdCipherLen(size_t passwordHashLen)
{
    /* SDP_PWD_HEAD_LEN plus specified hash length */
    return (size_t)(SDP_PWD_HEAD_LEN + passwordHashLen);
}

/* Protection password */
unsigned long SdpProtectPwd(WsecUint32 algId, WsecUint32 iter, const unsigned char *plainText, WsecUint32 plainLen,
    unsigned char *cipherText, WsecUint32 cipherLen)
{
    SdpPwdHeader *pwdHeader = NULL;
    unsigned long ret;
    Pbkdf2ParamConst pbkdf2Param;

    /* Check the input parameters. */
    if (plainText == NULL || cipherText == NULL || cipherLen < SDP_PWD_HEAD_LEN || plainText == cipherText) {
        return WSEC_ERR_INVALID_ARG;
    }

    ret = CheckKsfV1();
    if (ret != WSEC_SUCCESS) {
        return ret;
    }

    /* Construct a header to obtain the working key. */
    if (memset_s(cipherText, (size_t)cipherLen, 0, (size_t)SDP_PWD_HEAD_LEN) != EOK) {
        return WSEC_ERR_INVALID_ARG;
    }
    pwdHeader = (SdpPwdHeader *)(WsecVoid *)cipherText;
    ret = SdpFillPwdCipherTextHeader(algId, iter, pwdHeader);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] Fill password cipher text header failed.");
        return ret;
    }

    /* Updating the Ciphertext Length */
    pwdHeader->cipherLen = cipherLen - SDP_PWD_HEAD_LEN;

    /* Password Hash Algorithm PBKDF2 */
    pbkdf2Param.salt = pwdHeader->salt;
    pbkdf2Param.saltLen = SDP_SALT_LEN;
    pbkdf2Param.iter = (int)pwdHeader->iter;
    ret = CacPbkdf2(pwdHeader->algId, plainText, plainLen,
        &pbkdf2Param, pwdHeader->cipherLen, cipherText + SDP_PWD_HEAD_LEN);
    if (ret != WSEC_SUCCESS) {
        WSEC_LOG_E("[SDP] CAC pbkdf2 encrypt password failed.");
        return WSEC_ERR_PBKDF2_FAIL;
    }

    /* Convert to network sequence */
    SdpCvtByteOrderForSdpPwdHeader(pwdHeader, WBCHOST2NETWORK);

    return WSEC_SUCCESS;
}

/* Verifying the Plaintext Password Preparation */
static unsigned long SdpVerifyPwdPrepare(const unsigned char *plainText, const unsigned char *cipherText,
    WsecUint32 cipherLen, SdpPwdHeader **header)
{
    unsigned long ret;
    SdpPwdHeader *temp = NULL;

    /* Check the input parameters. */
    if (plainText == NULL || cipherText == NULL || cipherLen < SDP_PWD_HEAD_LEN || plainText == cipherText) {
        return WSEC_ERR_INVALID_ARG;
    }

    ret = CheckKsfV1();
    if (ret != WSEC_SUCCESS) {
        return ret;
    }

    do {
        temp = (SdpPwdHeader *)WSEC_MALLOC(sizeof(SdpPwdHeader));
        if (temp == NULL) {
            WSEC_LOG_E("[SDP] Memory for cipher head allocation failed.");
            ret = WSEC_ERR_MALLOC_FAIL;
            break;
        }
        if (memcpy_s(temp, sizeof(SdpPwdHeader), cipherText, sizeof(SdpPwdHeader)) != EOK) {
            WSEC_LOG_E4MEMCPY;
            ret = WSEC_ERR_MEMCPY_FAIL;
            break;
        }

        /* Convert to host order */
        SdpCvtByteOrderForSdpPwdHeader(temp, WBCNETWORK2HOST);

        /* check head */
        if (temp->version != SDP_PWD_CIPHER_VER) {
            WSEC_LOG_E2("[SDP] Ciphertext version expect %u, actually %u", SDP_PWD_CIPHER_VER, temp->version);
            ret = WSEC_ERR_SDP_VERSION_INCOMPATIBLE;
            break;
        }
        if (!KMC_IS_KEYITERATIONS_VALID(temp->iter)) {
            WSEC_LOG_E("[SDP] Iterator count is out of bounds.");
            ret = WSEC_ERR_SDP_INVALID_CIPHER_TEXT;
            break;
        }
        if (WSEC_ALGTYPE_UNKNOWN == CacAlgIdToType(temp->algId)) {
            WSEC_LOG_E("[SDP] CAC Get algorithm types failed.");
            ret = WSEC_ERR_SDP_ALG_NOT_SUPPORTED;
            break;
        }

        if (cipherLen < SDP_PWD_HEAD_LEN + temp->cipherLen) {
            WSEC_LOG_E("[SDP] Invalid parameter. Buffer for cipher text is not enough.");
            ret = WSEC_ERR_INPUT_BUFF_NOT_ENOUGH;
            break;
        }
    } while (0);
    if (ret != WSEC_SUCCESS) {
        WSEC_FREE(temp);
    }
    *header = temp;
    return ret;
}

/* Plaintext password authentication */
unsigned long SdpVerifyPwd(const unsigned char *plainText, WsecUint32 plainLen,
    const unsigned char *cipherText, WsecUint32 cipherLen)
{
    SdpPwdHeader *header = NULL;
    unsigned long ret;
    unsigned char *tempCipherText = NULL;
    WsecUint32 algType = WSEC_ALGTYPE_UNKNOWN;
    Pbkdf2ParamConst pbkdf2Param;

    ret = SdpVerifyPwdPrepare(plainText, cipherText, cipherLen, &header);
    if (ret != WSEC_SUCCESS) {
        return ret;
    }
    do {
        /* Obtains the algorithm type. */
        ret = SdpGetAlgPropertyEx(header->algId, &algType, NULL, NULL, NULL);
        if (ret != WSEC_SUCCESS) {
            WSEC_LOG_E("[SDP] Get algorithm property failed.");
            break;
        }
        if (algType != WSEC_ALGTYPE_PBKDF) {
            WSEC_LOG_E1("[SDP] algType(%u) is out of bounds.", algType);
            ret = WSEC_ERR_SDP_INVALID_CIPHER_TEXT;
            break;
        }

        /* No long password is required. */
        tempCipherText = (unsigned char *)WSEC_MALLOC(header->cipherLen > 0
                                                      ? header->cipherLen : 32); /* 0: len of the long pwd hash 32. */
        if (tempCipherText == NULL) {
            WSEC_LOG_E("[SDP] Memory for cipher data allocate failed.");
            ret = WSEC_ERR_MALLOC_FAIL;
            break;
        }

        /* Password Hash Algorithm PBKDF2 */
        pbkdf2Param.salt = header->salt;
        pbkdf2Param.saltLen = SDP_SALT_LEN;
        pbkdf2Param.iter = (int)header->iter;
        ret = CacPbkdf2(header->algId, plainText, plainLen, &pbkdf2Param, header->cipherLen, tempCipherText);
        if (ret != WSEC_SUCCESS) {
            ret = WSEC_ERR_PBKDF2_FAIL;
            WSEC_LOG_E("[SDP] CAC pbkdf2 encrypt password failed.");
            break;
        }

        /* Verification */
        if (WSEC_MEMCMP(tempCipherText, cipherText + SDP_PWD_HEAD_LEN, header->cipherLen) != 0) {
            ret = WSEC_ERR_SDP_PWD_VERIFY_FAIL;
            WSEC_LOG_E("[SDP] Password cipher text failed to pass the verification.");
            break;
        }

        ret = WSEC_SUCCESS;
    } while (0);

    WSEC_FREE(tempCipherText);
    WSEC_FREE(header);
    return ret;
}

/* Get mac len by cipherAlgId and hmacAlgId */
unsigned long SdpGetMacLenForEncrypt(WsecUint32 cipherAlgId, WsecUint32 hmacAlgId, WsecUint32 *macLen)
{
    if (macLen == NULL) {
        return WSEC_ERR_INVALID_ARG;
    }

    /* AES-GCM with tag, the len is WSEC_AES_GCM_TAGLEN */
    if (CheckIsGcmAlgId(cipherAlgId) == WSEC_TRUE) {
        *macLen = WSEC_AES_GCM_TAGLEN;
        return WSEC_SUCCESS;
    }

    if (CheckIsAlgValid(cipherAlgId, hmacAlgId) == WSEC_FALSE) {
        return WSEC_ERR_SDP_ALG_NOT_SUPPORTED;
    }

    /* AES-CBC without hmac, the len is 0 */
    if (hmacAlgId == WSEC_ALGID_UNKNOWN) {
        *macLen = 0;
        return WSEC_SUCCESS;
    }

    /* AES-CBC with hmac, the len is depend on hmac alg */
    *macLen = CacHMACSize(hmacAlgId);
    return WSEC_SUCCESS;
}
