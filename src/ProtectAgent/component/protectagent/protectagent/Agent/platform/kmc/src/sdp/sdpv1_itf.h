/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2014-2020. All rights reserved.
 * Description: header file of the external interfaces compatible with SDP V1
 * Author: x00102361
 * Create: 2014-06-16
 * History: 2018-10-08 Zhang Jie (employee ID: 00316590) UK rectification, compatible with SDP V1
 */

#ifndef KMC_SRC_SDP_SDPV1_ITF_H
#define KMC_SRC_SDP_SDPV1_ITF_H

#include "wsecv2_type.h"
#include "sdpv3_type.h"

#ifdef __cplusplus
#if __cplusplus
extern "C" {
#endif
#endif /* __cplusplus */

/* Contains the length of reserved bytes, which cannot be changed. */
#define SDP_CIPHER_HEAD_LEN     68
#define SDP_HMAC_HEAD_LEN       44
#define SDP_PWD_HEAD_LEN        40
#define SDP_CIPHER_FILE_FLAG    32

typedef enum {
    SDP_CFT_FILE_HDR = 1, /* Ciphertext file header */
    SDP_CFT_CIPHER_HDR,   /* Ciphertext header */
    SDP_CFT_CIPHER_BODY,  /* Ciphertext body */
    SDP_CFT_HMAC_VAL      /* HMAC value */
} SdpCipherFileTlv;

/* Symmetrically encrypted data header */
#pragma pack(1)
typedef struct {
    WsecUint32    version;            /* Data protection module version */
    /*
     * Indicates whether the plaintext HMAC is included.
     * If the HMAC is included, the plaintext HMAC is placed after the ciphertext.
     */
    WsecUint32    hmacFlag;
    WsecUint32    domain;             /* Field corresponding to the key ID */
    WsecUint32    algId;              /* Algorithm ID */
    WsecUint32    keyId;              /* Key ID used to calculate the HMAC */
    /* Iteration round, which is configured by the application for the key management module to derive working keys. */
    WsecUint32    iter;
    unsigned char salt[SDP_SALT_LEN]; /* Salt generated by the data protection module. */
    unsigned char iv[SDP_IV_MAX_LEN]; /* Salt generated by the data protection module. */
    WsecUint32    cipherLen;          /* Length of the encrypted ciphertext data */
} SdpCipherHeader;
#pragma pack()

/* HMAC Header Definition */
#pragma pack(1)
typedef struct {
    WsecUint32    version;            /* Data protection module version */
    WsecUint32    domain;             /* Field corresponding to the key ID */
    WsecUint32    algId;              /* Algorithm ID */
    WsecUint32    keyId;              /* Key ID used to calculate the HMAC */
    /* Iteration round, which is configured by the application for the key management module to derive working keys. */
    WsecUint32    iter;
    unsigned char salt[SDP_SALT_LEN]; /* Salt generated by the data protection module. */
} SdpHmacHeader;
#pragma pack()

#pragma pack(1)
typedef struct {
    union {
        unsigned char   buff[SDP_CIPHER_HEAD_LEN];
        SdpCipherHeader cipherHeader;
    };
} SdpCipherHeaderBuff;
#pragma pack()

#pragma pack(1)
typedef struct {
    union {
        unsigned char buff[SDP_HMAC_HEAD_LEN];
        SdpHmacHeader hmacHeader;
    };
} SdpHmacAlgAttributes;
#pragma pack()

#pragma pack(1)
typedef struct {
    SdpCipherHeaderBuff  cipherBuff;
    SdpHmacAlgAttributes hmacBuff;
} SdpBodCipherHeader;
#pragma pack()

#pragma pack(1)
typedef struct {
    unsigned char flag[SDP_CIPHER_FILE_FLAG]; /* Format identifier length: 32 */
    WsecUint32    version;                    /* Ciphertext file version */
    WsecUint32    plainBlockLenMax;           /* Maximum length of a plaintext segment */
    WsecUint32    cipherBlockLenMax;          /* Maximum length of a ciphertext segment */
    WsecSysTime   createUtc;                  /* Ciphertext file generation time (UTC) */
    WsecSysTime   srcCreateTime;              /* Time when a source file is created. */
    WsecSysTime   srcEditTime;                /* Latest modification time of the source file. */
    unsigned char reserve[16];                /* 16 bytes are reserved. */
} SdpCipherFileHeader;
#pragma pack()

/* File Time Settings */
typedef WsecBool(*CallbackGetFileDateTime)(const char *fileName,
    WsecSysTime *createTime, WsecSysTime *lastEditTime);
/* Obtaining the File Time */
typedef WsecVoid(*CallbackSetFileDateTime)(const char *fileName,
    const WsecSysTime *createTime, const WsecSysTime *lastEditTime);

/* 1. Encryption and decryption */
/* Calculating the Ciphertext Length Based on the Plaintext Length */
unsigned long SdpGetCipherDataLen(WsecUint32 plainLen, WsecUint32 *cipherLen);

/* Small-size data encryption */
unsigned long SdpEncrypt(WsecUint32 domain,
    WsecUint32 cipherAlgId,
    WsecUint32 hmacAlgId,
    const unsigned char *plainText,
    WsecUint32 plainLen,
    unsigned char *cipherText,
    WsecUint32 *cipherLen);

/* Small data decryption */
unsigned long SdpDecrypt(WsecUint32 domain,
    const unsigned char *cipherText,
    WsecUint32 cipherLen,
    unsigned char *plainText,
    WsecUint32 *plainLen);

/* Stream Data Encryption - Start */
unsigned long SdpEncryptInit(WsecUint32 domain,
    WsecUint32 cipherAlgId,
    WsecUint32 hmacAlgId,
    WsecHandle *ctx,
    SdpBodCipherHeader *bodCipherHeader);

/* Stream Data Encryption-Add */
unsigned long SdpEncryptUpdate(WsecHandle *ctx,
    const unsigned char *plainText,
    WsecUint32 plainLen,
    unsigned char *cipherText,
    WsecUint32 *cipherLen);

/* Stream Data Encryption - Termination */
unsigned long SdpEncryptFinal(WsecHandle *ctx,
    unsigned char *cipherText,
    WsecUint32 *cipherLen,
    unsigned char *hmacText,
    WsecUint32 *hmacLen);

/* Stream data decryption-start */
unsigned long SdpDecryptInit(WsecUint32 domain,
    WsecHandle *ctx,
    const SdpBodCipherHeader *bodCipherHeader);

/* Stream Data Decryption-Add */
unsigned long SdpDecryptUpdate(WsecHandle *ctx,
    const unsigned char *cipherText,
    WsecUint32 cipherLen,
    unsigned char *plainText,
    WsecUint32 *plainLen);

/* Stream data decryption-termination */
unsigned long SdpDecryptFinal(WsecHandle *ctx,
    const unsigned char *hmacText,
    WsecUint32 hmacLen,
    unsigned char *plainText,
    WsecUint32 *plainLen);

/* Encrypting a File */
unsigned long SdpFileEncrypt(WsecUint32 domain,
    WsecUint32 cipherAlgId,
    WsecUint32 hmacAlgId,
    const char *plainFile,
    const char *cipherFile,
    const CallbackGetFileDateTime getFileDateTime);

/* Decrypting a File */
unsigned long SdpFileDecrypt(WsecUint32 domain,
    const char *cipherFile,
    const char *plainFile,
    const CallbackSetFileDateTime setFileDateTime);

/* Obtain the ciphertext header based on the ciphertext. */
unsigned long SdpGetCipherHeaderV1(const unsigned char *ciphertext, WsecUint32 ciphertextLen,
    SdpCipherHeader *cipherHeader);

/* Obtains MKInfo based on BodCipherHeader. */
unsigned long SdpGetMkDetailByBodCipherHeader(SdpBodCipherHeader *bodCipherHeader, KmcMkInfo *mkInfo);

/* Obtain the ciphertext header based on the ciphertext file. */
unsigned long SdpGetMkDetailByCipherFile(const char *cipherFile, KmcMkInfo *mkInfo);

/* Obtain the value of BodCipherHeader based on the ciphertext file. */
unsigned long SdpGetBodCipherHeaderByCipherFile(const char *cipherFile, SdpBodCipherHeader *header);

/* III. Password Protection */
/* Obtains the length of the password protection result. */
size_t SdpGetPwdCipherLen(size_t passwordHashLen);

/* Protection password */
unsigned long SdpProtectPwd(WsecUint32 algId,
    WsecUint32 iter,
    const unsigned char *plainText,
    WsecUint32 plainLen,
    unsigned char *cipherText,
    WsecUint32 cipherLen);

/* Plaintext password authentication */
unsigned long SdpVerifyPwd(const unsigned char *plainText,
    WsecUint32 plainLen,
    const unsigned char *cipherText,
    WsecUint32 cipherLen);

/* HMAC Compatible Interface Prototype in KMCV100 */
/* Obtains the maximum possible HMAC length. */
unsigned long SdpGetHmacLen(WsecUint32 *hmacLen);

/* Calculates the HMAC of the specified data using the key in the specified domain and the specified algorithm ID. */
unsigned long SdpHmac(WsecUint32 domain,
    WsecUint32 algId,
    const unsigned char *plainText, WsecUint32 plaintextLen,
    unsigned char *hmacData, WsecUint32 *hmacLen);

/* Check whether the HMAC result is correct. */
unsigned long SdpVerifyHmac(WsecUint32 domain,
    const unsigned char *plainText, WsecUint32 plaintextLen,
    const unsigned char *hmacData, WsecUint32 hmacLen);

/* Specify the domain and algorithm ID, and obtain SdpHmacAlgAttributes for SdpHmacInit or SdpFileHmac. */
unsigned long SdpGetHmacAlgAttr(WsecUint32 domain, WsecUint32 algId, SdpHmacAlgAttributes *hmacAlgAttributes);

/* Specify a domain, specify SdpHmacAlgAttributes, and obtain ctx for SdpHmacUpdate and SdpHmacFinal. */
unsigned long SdpHmacInit(WsecUint32 domain, const SdpHmacAlgAttributes *hmacAlgAttributes, WsecHandle *ctx);

/* Performs HMAC on data and can be invoked for multiple times. */
unsigned long SdpHmacUpdate(const WsecHandle *ctx, const unsigned char *plainText, WsecUint32 plaintextLen);

/* Obtains the HMAC of specified data in SdpHmacUpdate. */
unsigned long SdpHmacFinal(WsecHandle *ctx, unsigned char *hmacData, WsecUint32 *hmacLen);

/* Specify the domain, SdpHmacAlgAttributes, and file path to obtain the HMAC result of the file data. */
unsigned long SdpFileHmac(WsecUint32 domain,
    const char *file,
    const SdpHmacAlgAttributes *hmacAlgAttributes,
    WsecVoid *hmacData, WsecUint32 *hmacLen);

/* Specify the domain, SdpHmacAlgAttributes, file path, file data HMAC, and HMAC authentication. */
unsigned long SdpVerifyFileHmac(WsecUint32 domain,
    const char *file,
    const SdpHmacAlgAttributes *hmacAlgAttributes,
    const WsecVoid *hmacData, WsecUint32 hmacLen);

/* Obtains MKInfo based on HmacData. */
unsigned long SdpGetMkDetailByHmacData(WsecVoid *hmacData, WsecUint32 hmacLen, KmcMkInfo *mkInfo);

/* Get mac len by symAlgID and hmacAlgID */
unsigned long SdpGetMacLenForEncrypt(WsecUint32 cipherAlgId, WsecUint32 hmacAlgID, WsecUint32 *macLen);

#ifdef __cplusplus
#if __cplusplus
}
#endif
#endif /* __cplusplus */

#endif /* KMC_SRC_SDP_SDPV1_ITF_H */
