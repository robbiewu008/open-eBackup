/*
版权所有 (c) 华为技术有限公司 2012-2018


原理:					ipv6数据类型专有变异算法
						

长度:					长度不变		,定值为16byte

数量:					n个

支持数据类型: 	ipv6

*/
#include "../common/PCommon.h"

// http://blog.csdn.net/cybertan/article/details/7197747
#ifdef __cplusplus
extern "C" {
#endif

// 特殊ipv6地址
static u8 g_ipv6Table[][16] = {
    {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0x20, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},

    {0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0x20, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},

    {0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0x20, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},

    {0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},

    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},

    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},

    {0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

    {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},

    {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
    {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05},
    {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06},
    {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09},
    {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a},
    {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16},

    {0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},

    // mac
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00},
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff},

    {0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},

    {0xfe, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xfe, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0xfe, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},

    {0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},

    {0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
    {0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
    // 0    8      16    24       32     40    48      56     64     72     80    88       96    104   112   120 
};

int Ipv6GetCount(SElement *pElement)
{
    ASSERT_NULL(pElement);

    return sizeof(g_ipv6Table) / 16;
}

char* Ipv6GetValue(SElement *pElement, int pos)
{
    int i = 0;
    
    ASSERT_NULL(pElement);

    SetElementInitoutBufEx(pElement, 16);
    
    HwMemcpy(pElement->para.value, pElement->inBuf, 16);

    // 后64bit
    if (pos == 0)
    {
        for (i = 64; i <= 127; i++)
        {
            FILL_BIT(pElement->para.value, i);
        }
    }

    if (pos == 1)
    {
        for (i = 64; i <= 127; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }
    }

    if (pos == 2)
    {
        for (i = 64; i <= 126; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        FILL_BIT(pElement->para.value, 127);
    }

    // mac
    if (pos == 3)
    {
        pElement->para.value[11] = 0xff;
        pElement->para.value[12] = 0xfe;
    }

    // subnet id
    if (pos == 4)
    {
        for (i = 48; i <= 63; i++)
        {
            FILL_BIT(pElement->para.value, i);
        }
    }

    if (pos == 5)
    {
        for (i = 48; i <= 63; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }
    }

    if (pos == 6)
    {
        for (i = 48; i <= 62; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        FILL_BIT(pElement->para.value, 63);
    }

    // global id
    if (pos == 7)
    {
        for (i = 16; i <= 47; i++)
        {
            FILL_BIT(pElement->para.value, i);
        }
    }

    if (pos == 8)
    {
        for (i = 16; i <= 47; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }
    }

    if (pos == 9)
    {
        for (i = 16; i <= 46; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        FILL_BIT(pElement->para.value, 47);
    }

    // 2000
    if (pos == 10)
    {
        for (i = 0; i <= 47; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        pElement->para.value[00] = 0x20;
        pElement->para.value[01] = 0x00;
    }

    // ff00
    if (pos == 10)
    {
        for (i = 0; i <= 47; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        pElement->para.value[00] = 0xff;
        pElement->para.value[01] = 0x00;
    }

    // ff01
    if (pos == 11)
    {
        for (i = 0; i <= 47; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        pElement->para.value[00] = 0xff;
        pElement->para.value[01] = 0x01;
    }

    // ff80
    if (pos == 12)
    {
        for (i = 0; i <= 47; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        pElement->para.value[00] = 0xff;
        pElement->para.value[01] = 0x80;
    }

    // ffc0
    if (pos == 13)
    {
        for (i = 0; i <= 47; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        pElement->para.value[00] = 0xff;
        pElement->para.value[01] = 0xc0;
    }

    // fc00
    if (pos == 14)
    {
        for (i = 0; i <= 47; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        pElement->para.value[00] = 0xfc;
        pElement->para.value[01] = 0x00;
    }

    // fd00
    if (pos == 15)
    {
        for (i = 0; i <= 47; i++)
        {
            ZERO_BIT(pElement->para.value, i);
        }

        pElement->para.value[00] = 0xfd;
        pElement->para.value[01] = 0x00;
    }

    if (pos >= 16)
    {
        // ip多播
        pos = pos - 16;
        for (i = 0; i < 16; i++)
        {
            pElement->para.value[i] = g_ipv6Table[pos][i];
        }
    }

    return pElement->para.value;
}


int Ipv6GetIsSupport(SElement *pElement)
{
    ASSERT_NULL(pElement);
    if (pElement->para.type == ENUM_IPV6)
    {
        return ENUM_YES;
    }

    return ENUM_NO;
}

const struct MutaterGroup g_ipv6Group = {
    "Ipv6",
    Ipv6GetCount,
    Ipv6GetValue,
    Ipv6GetIsSupport,
    1
};

void InitIpv6(void)
{
    RegisterMutater(&g_ipv6Group, ENUM_MIPV6);
}

#ifdef __cplusplus
}
#endif

