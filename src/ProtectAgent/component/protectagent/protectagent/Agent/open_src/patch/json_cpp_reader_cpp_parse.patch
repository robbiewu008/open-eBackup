--- jsoncpp/src/lib_json/json_reader.cpp	2022-04-08 02:19:30.000000000 -0400
+++ jsoncpp_new/src/lib_json/json_reader.cpp	2022-04-07 22:04:16.000000000 -0400
@@ -94,14 +94,14 @@
 }
 
 bool Reader::parse(const std::string& document, Value& root,
-                   bool collectComments) {
+                   bool collectComments, const int deepLimit) {
   document_.assign(document.begin(), document.end());
   const char* begin = document_.c_str();
   const char* end = begin + document_.length();
-  return parse(begin, end, root, collectComments);
+  return parse(begin, end, root, collectComments, deepLimit);
 }
 
-bool Reader::parse(std::istream& is, Value& root, bool collectComments) {
+bool Reader::parse(std::istream& is, Value& root, bool collectComments, const int deepLimit) {
   // std::istream_iterator<char> begin(is);
   // std::istream_iterator<char> end;
   // Those would allow streamed input from a file, if parse() were a
@@ -111,15 +111,15 @@
   // create an extra copy.
   String doc;
   std::getline(is, doc, static_cast<char> EOF);
-  return parse(doc.data(), doc.data() + doc.size(), root, collectComments);
+  return parse(doc.data(), doc.data() + doc.size(), root, collectComments, deepLimit);
 }
 
 bool Reader::parse(const char* beginDoc, const char* endDoc, Value& root,
-                   bool collectComments) {
+                   bool collectComments, const int deepLimit) {
   if (!features_.allowComments_) {
     collectComments = false;
   }
-
+  int currentDeep = 0;
   begin_ = beginDoc;
   end_ = endDoc;
   collectComments_ = collectComments;
@@ -132,7 +132,7 @@
     nodes_.pop();
   nodes_.push(&root);
 
-  bool successful = readValue();
+  bool successful = readValue(currentDeep, deepLimit);
   Token token;
   skipCommentTokens(token);
   if (collectComments_ && !commentsBefore_.empty())
@@ -153,11 +153,15 @@
   return successful;
 }
 
-bool Reader::readValue() {
+bool Reader::readValue(int currentDeep, const int deepLimit) {
   // readValue() may call itself only if it calls readObject() or ReadArray().
   // These methods execute nodes_.push() just before and nodes_.pop)() just
   // after calling readValue(). parse() executes one nodes_.push(), so > instead
   // of >=.
+  if (++currentDeep > deepLimit && currentDeep > 0 && deepLimit > 0) {
+    return false;
+  }
+  
   if (nodes_.size() > stackLimit_g)
     throwRuntimeError("Exceeded stackLimit in readValue().");
 
@@ -176,7 +180,7 @@
     currentValue().setOffsetLimit(current_ - begin_);
     break;
   case tokenArrayBegin:
-    successful = readArray(token);
+    successful = readArray(token, currentDeep, deepLimit);
     currentValue().setOffsetLimit(current_ - begin_);
     break;
   case tokenNumber:
@@ -501,7 +505,11 @@
                             tokenObjectEnd);
 }
 
-bool Reader::readArray(Token& token) {
+bool Reader::readArray(Token& token, int currentDeep, const int deepLimit) {
+
+  if (++currentDeep > deepLimit && currentDeep > 0 && deepLimit > 0) {
+    return false;
+  }
   Value init(arrayValue);
   currentValue().swapPayload(init);
   currentValue().setOffsetStart(token.start_ - begin_);
@@ -516,7 +524,7 @@
   for (;;) {
     Value& value = currentValue()[index++];
     nodes_.push(&value);
-    bool ok = readValue();
+    bool ok = readValue(currentDeep, deepLimit);
     nodes_.pop();
     if (!ok) // error already set
       return recoverFromError(tokenArrayEnd);
